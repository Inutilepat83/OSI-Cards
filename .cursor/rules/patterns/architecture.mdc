---
description: "Angular component architecture, SOLID principles, component patterns"
alwaysApply: true
---

# Architecture Patterns

## Angular Component Architecture

### Component-Based Architecture

Angular applications are built with **components** as the primary architectural unit.

### Component Hierarchy

```
┌─────────────────────────────────────┐
│      Root Component (App)           │
├─────────────────────────────────────┤
│      Feature Components             │
│      (Cards, Sections, etc.)        │
├─────────────────────────────────────┤
│      Presentational Components      │
│      (Actions, Headers, etc.)       │
└─────────────────────────────────────┘
```

### Architecture Layers

**For Angular library:**

1. **Presentation Layer** - Components (standalone, OnPush)
2. **Service Layer** - Business logic, state management
3. **Model Layer** - Types, interfaces, data structures
4. **Utility Layer** - Helper functions, utilities

### Implementation Guidelines

- **Components**: Standalone, OnPush, focused on presentation
- **Services**: Injectable, business logic, state management
- **Models**: Type definitions, interfaces, data structures
- **Utilities**: Pure functions, helpers, validators

---

## Component Patterns

### Container/Presentational Pattern

**Container Components** (smart):
- Fetch data
- Manage state
- Handle business logic
- Pass data to presentational components

**Presentational Components** (dumb):
- Receive data via `@Input()`
- Emit events via `@Output()`
- No direct service dependencies
- Reusable and testable

### Example

**See actual codebase examples:**
- Container: `OsiCardsComponent` (wraps `AICardRendererComponent`)
- Presentational: `CardActionsComponent`, `CardHeaderComponent` (receive data via @Input, emit via @Output)

```typescript
// Container Component (Smart) - Similar to OsiCardsComponent
@Component({
  selector: 'app-card-container',
  template: `
    <app-card
      [card]="card()"
      (actionClick)="onActionClick($event)">
    </app-card>
  `,
})
export class CardContainerComponent {
  private readonly cardService = inject(CardFacadeService); // See CardFacadeService
  readonly card = toSignal(this.cardService.card$);
  
  onActionClick(action: CardAction): void {
    this.cardService.handleAction(action);
  }
}

// Presentational Component (Dumb) - Similar to CardActionsComponent
@Component({
  selector: 'app-card',
  template: `<!-- Card presentation -->`,
})
export class CardComponent {
  @Input() card?: AICardConfig;
  @Output() actionClick = new EventEmitter<CardAction>();
}
```

---

## Service Layer Patterns

### Facade Pattern

**Provide a unified interface** to a complex subsystem.

**Real example:** `CardFacadeService` (`projects/osi-cards-lib/src/lib/services/card-facade.service.ts`)

```typescript
@Injectable({ providedIn: 'root' })
export class CardFacadeService {
  private readonly streamingService = inject(OSICardsStreamingService);
  private readonly themeService = inject(ThemeService);
  
  // Unified API
  readonly card = toSignal(this.cardService.card$);
  readonly theme = toSignal(this.themeService.theme$);
  
  createCard(config: AICardConfig): void {
    this.cardService.create(config);
  }
  
  streamCard(json: string): Observable<CardUpdate> {
    return this.streamingService.stream(json);
  }
}
```

### Guidelines

- Use facade pattern for complex subsystems (see `CardFacadeService` for example)
- Provide simple, unified API
- Hide implementation details
- Make services injectable with `providedIn: 'root'`

---

## State Management Patterns

### Service-Based State (Simple)

**Use services for simple state management:**

```typescript
@Injectable({ providedIn: 'root' })
export class ThemeService {
  private readonly themeSubject = new BehaviorSubject<'day' | 'night'>('day');
  readonly theme$ = this.themeSubject.asObservable();
  
  setTheme(theme: 'day' | 'night'): void {
    this.themeSubject.next(theme);
  }
}
```

### Signal-Based State (Modern)

**Use signals for reactive state (Angular 16+):**

```typescript
@Injectable({ providedIn: 'root' })
export class ThemeService {
  private readonly themeState = signal<'day' | 'night'>('day');
  readonly theme = this.themeState.asReadonly();
  
  setTheme(theme: 'day' | 'night'): void {
    this.themeState.set(theme);
  }
}
```

### NgRx (Complex State)

**Use NgRx for complex state management** (when needed):
- Multiple features
- Complex state relationships
- Time-travel debugging
- State persistence

### Guidelines

- Use services for simple state
- Use signals for reactive state (Angular 16+)
- Use NgRx only when complexity justifies it
- Keep state management simple

---

## Dependency Injection Patterns

### inject() Function (Modern)

**Prefer `inject()` function for dependency injection:**

```typescript
export class MyComponent {
  private readonly myService = inject(MyService);
  private readonly config = inject(CONFIG_TOKEN, { optional: true });
}
```

### Constructor Injection (Alternative)

**Can use constructor injection:**

```typescript
export class MyComponent {
  constructor(
    private readonly myService: MyService,
    @Optional() @Inject(CONFIG_TOKEN) private readonly config?: Config
  ) {}
}
```

### Guidelines

- Prefer `inject()` function (modern, cleaner)
- Use constructor injection if preferred
- Use `{ optional: true }` for optional dependencies
- Never manually instantiate services

---

## SOLID Principles

### Single Responsibility Principle (SRP)

A class should have only one reason to change.

**Examples:**
- Component: Renders UI
- Service: Handles business logic
- Utility: Performs specific calculation

### Open/Closed Principle (OCP)

Open for extension, closed for modification.

**Examples:**
- Base component classes
- Abstract services
- Plugin architecture

### Liskov Substitution Principle (LSP)

Subtypes must be substitutable for their base types.

**Examples:**
- Component inheritance
- Interface implementations
- Service implementations

### Interface Segregation Principle (ISP)

Clients should not depend on interfaces they don't use.

**Examples:**
- Small, focused interfaces
- Component interfaces
- Service interfaces

### Dependency Inversion Principle (DIP)

Depend on abstractions, not concretions.

**Examples:**
- Service interfaces
- Injection tokens
- Abstract base classes

---

## Code Organization

### Feature-Based Organization

**Organize code by feature:**

```
lib/
├── components/
│   ├── cards/
│   │   ├── ai-card-renderer/
│   │   └── osi-cards/
│   └── sections/
│       ├── info-section/
│       └── analytics-section/
├── services/
│   ├── card.service.ts
│   └── theme.service.ts
└── models/
    ├── card.model.ts
    └── section.model.ts
```

### Guidelines

- Organize by feature, not by type
- Keep related code together
- Use barrel exports (`index.ts`)
- Keep components close to their styles
- Keep tests next to source files

---

## Architecture Checklist

Before creating new features:

- [ ] Component structure planned
- [ ] Services identified
- [ ] State management approach chosen
- [ ] Dependency injection designed
- [ ] SOLID principles followed
- [ ] Code organization planned
- [ ] Interfaces/types defined
- [ ] Error handling considered
- [ ] Testing strategy defined

**Examples:**
- See `CardFacadeService` (`projects/osi-cards-lib/src/lib/services/card-facade.service.ts`) for facade pattern
- See `ThemeService` (`projects/osi-cards-lib/src/lib/themes/theme.service.ts`) for service patterns
- See `AICardRendererComponent` for container/presentational pattern

**See also:** `angular-components.mdc`, `error-handling.mdc`, `testing.mdc`
