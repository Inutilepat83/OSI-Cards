---
description: "Angular error handling: ErrorHandler, ErrorBoundary, structured error handling"
alwaysApply: true
---

# Error Handling Patterns

## Angular Error Handling

### ErrorHandler (Global Error Handler)

**Use Angular's `ErrorHandler` for global error handling:**

```typescript
import { ErrorHandler, Injectable } from '@angular/core';
import { ErrorTrackingService } from './error-tracking.service';

@Injectable()
export class GlobalErrorHandler implements ErrorHandler {
  private readonly errorTracker = inject(ErrorTrackingService);
  
  handleError(error: Error): void {
    // Log error
    console.error('Global error:', error);
    
    // Track error
    this.errorTracker.logError({
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
    });
    
    // Optionally notify user
    // this.notificationService.showError('An error occurred');
  }
}
```

### Provider Configuration

```typescript
// app.config.ts
import { ApplicationConfig, ErrorHandler } from '@angular/core';

export const appConfig: ApplicationConfig = {
  providers: [
    { provide: ErrorHandler, useClass: GlobalErrorHandler },
    // ... other providers
  ],
};
```

### Guidelines

- Implement `ErrorHandler` for global error handling
- Log errors to error tracking service
- Don't expose internal details to users
- Provide user-friendly error messages
- Track errors for debugging

---

## Error Boundary Components

### ErrorBoundaryComponent Pattern

**Use error boundary components to catch component errors:**

```typescript
import { Component, Input, Output, EventEmitter, OnInit, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-error-boundary',
  template: `
    @if (hasError()) {
      <div class="error-boundary" role="alert">
        <div class="error-boundary__default">
          <h3>Something went wrong</h3>
          <p>{{ errorDetails()?.error?.message }}</p>
          @if (recoveryStrategy() === 'retry') {
            <button (click)="retry()">Try Again</button>
          }
          <button (click)="reset()">Dismiss</button>
        </div>
      </div>
    } @else {
      <ng-content></ng-content>
    }
  `,
  standalone: true,
  imports: [CommonModule],
})
export class ErrorBoundaryComponent implements OnInit, OnDestroy {
  @Input() fallbackUI?: TemplateRef<any>;
  @Input() recoveryStrategy = signal<RecoveryStrategy>('retry');
  @Input() showDetails = signal(false);
  @Input() reportErrors = true;
  
  @Output() errorCaught = new EventEmitter<ErrorBoundaryError>();
  @Output() errorRecovered = new EventEmitter<void>();
  
  hasError = signal(false);
  errorDetails = signal<ErrorBoundaryError | null>(null);
  
  private destroy$ = new Subject<void>();
  
  ngOnInit(): void {
    this.setupErrorHandler();
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  handleError(error: Error, errorInfo?: any): void {
    const errorDetails: ErrorBoundaryError = {
      error,
      errorInfo,
      timestamp: Date.now(),
      recovered: false,
    };
    
    this.hasError.set(true);
    this.errorDetails.set(errorDetails);
    this.errorCaught.emit(errorDetails);
    
    if (this.reportErrors) {
      this.reportError(errorDetails);
    }
  }
  
  retry(): void {
    this.reset();
    this.errorRecovered.emit();
  }
  
  reset(): void {
    this.hasError.set(false);
    this.errorDetails.set(null);
  }
  
  private setupErrorHandler(): void {
    // Set up global error handler for this boundary
  }
  
  private reportError(error: ErrorBoundaryError): void {
    // Report to error tracking service
  }
}
```

### Usage

```html
<app-error-boundary
  [recoveryStrategy]="'retry'"
  (errorCaught)="onError($event)">
  <my-component></my-component>
</app-error-boundary>
```

### Guidelines

- Use error boundaries for component error handling
- Provide fallback UI for errors
- Support error recovery strategies
- Emit errors for parent handling
- Don't expose internal error details to users

---

## HTTP Error Handling

### HTTP Interceptor Pattern

**Use HTTP interceptors for HTTP error handling:**

```typescript
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpErrorResponse } from '@angular/common/http';
import { catchError, throwError } from 'rxjs';

@Injectable()
export class HttpErrorInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        // Handle specific error types
        if (error.status === 401) {
          // Handle unauthorized
          this.handleUnauthorized();
        } else if (error.status === 404) {
          // Handle not found
          this.handleNotFound();
        } else if (error.status >= 500) {
          // Handle server errors
          this.handleServerError(error);
        }
        
        // Log error
        console.error('HTTP error:', error);
        
        // Return user-friendly error
        return throwError(() => new Error('An error occurred. Please try again.'));
      })
    );
  }
  
  private handleUnauthorized(): void {
    // Redirect to login, etc.
  }
  
  private handleNotFound(): void {
    // Show not found message
  }
  
  private handleServerError(error: HttpErrorResponse): void {
    // Log to error tracking service
  }
}
```

### Provider Configuration

```typescript
// app.config.ts
import { provideHttpClient, withInterceptors } from '@angular/common/http';

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([HttpErrorInterceptor])
    ),
    // ... other providers
  ],
};
```

### Guidelines

- Use HTTP interceptors for HTTP error handling
- Handle specific HTTP status codes
- Provide user-friendly error messages
- Log errors to error tracking service
- Don't expose server error details to users

---

## Error Categories

### 1. Component Errors

Errors that occur in component rendering or lifecycle.

**Handling:**
- Use error boundary components
- Provide fallback UI
- Support error recovery
- Don't expose stack traces to users

### 2. HTTP Errors

Errors from HTTP requests.

**Handling:**
- Use HTTP interceptors
- Handle specific status codes
- Provide user-friendly messages
- Log errors for debugging

### 3. Validation Errors

Input validation failures.

**Handling:**
- Show field-level errors
- Use Angular forms validation
- Provide clear error messages
- Don't block user input unnecessarily

### 4. Runtime Errors

Unexpected errors during execution.

**Handling:**
- Use global error handler
- Log errors to tracking service
- Show user-friendly messages
- Support error recovery when possible

---

## Error Logging

### Structured Logging

```typescript
interface ErrorLog {
  message: string;
  stack?: string;
  component?: string;
  user?: string;
  timestamp: string;
  context?: Record<string, unknown>;
}

class ErrorTrackingService {
  logError(error: ErrorLog): void {
    // Log to console in development
    if (isDevMode()) {
      console.error('Error:', error);
    }
    
    // Send to error tracking service (production)
    if (!isDevMode()) {
      this.sendToTrackingService(error);
    }
  }
  
  private sendToTrackingService(error: ErrorLog): void {
    // Send to error tracking service (e.g., Sentry, LogRocket)
  }
}
```

### Guidelines

- Log errors with context
- Include timestamps
- Include user information (if available)
- Log to console in development
- Send to tracking service in production
- Don't log sensitive information

---

## Error Recovery

### Retry Strategy

**Implement retry for recoverable errors:**

```typescript
import { retry, catchError } from 'rxjs/operators';

this.http.get('/api/data').pipe(
  retry({
    count: 3,
    delay: 1000, // 1 second delay
  }),
  catchError((error) => {
    // Handle error after retries exhausted
    return throwError(() => error);
  })
).subscribe();
```

### Guidelines

- Use retry for transient errors (network, timeouts)
- Set maximum retry attempts
- Use exponential backoff for retries
- Don't retry for permanent errors (400, 404)
- Provide feedback during retries

---

## User-Friendly Error Messages

### Error Message Patterns

**Provide user-friendly error messages:**

```typescript
const ERROR_MESSAGES: Record<string, string> = {
  'network': 'Network error. Please check your connection.',
  'timeout': 'Request timed out. Please try again.',
  'not-found': 'The requested resource was not found.',
  'server-error': 'Server error. Please try again later.',
  'validation': 'Please check your input and try again.',
  'unknown': 'An unexpected error occurred. Please try again.',
};

function getUserFriendlyMessage(error: Error): string {
  // Map technical errors to user-friendly messages
  if (error.message.includes('network')) {
    return ERROR_MESSAGES['network'];
  }
  // ... etc
  
  return ERROR_MESSAGES['unknown'];
}
```

### Guidelines

- Provide user-friendly error messages
- Don't expose technical details to users
- Use clear, actionable language
- Provide recovery suggestions
- Log technical details server-side

---

## Error Handling Checklist

Before implementing error handling:

- [ ] Global error handler implemented
- [ ] Error boundary components used where needed
- [ ] HTTP error interceptor configured
- [ ] Error logging service implemented
- [ ] User-friendly error messages defined
- [ ] Error recovery strategies planned
- [ ] Error tracking service configured
- [ ] Error handling tested

**See also:** `architecture.mdc`, `security.mdc`, `testing.mdc`, `angular-components.mdc`
