---
description: 'Deep thinking protocol - scale thinking depth by task complexity'
priority: 0
---

# Deep Thinking Protocol

## üß† Thinking Depth by Complexity

**Scale thinking depth based on task complexity:**

- **Simple tasks**: Quick checks (requirements, patterns, consistency)
- **Moderate tasks**: Standard process (understand, plan, implement, verify)
- **Complex tasks**: Deep analysis (multiple solutions, trade-offs, thorough planning)

---

## Step 1: Understand the Problem

### Read Full Context

- Read the entire request
- Read relevant code files
- Read related documentation
- Understand the full picture

### Identify Root Cause

- What is the actual problem?
- What are the symptoms?
- What is the underlying issue?
- Why is this happening?

### Consider Implications

- What are the side effects?
- What could break?
- What are the dependencies?
- What are the risks?

### Ask Clarifying Questions

- Is the problem fully understood?
- Are there missing details?
- Are there assumptions?
- What are the constraints?

---

## Step 2: Plan the Solution

### Break Down the Problem

- What are the sub-problems?
- What are the steps needed?
- What is the order of operations?
- What are the dependencies?

### Consider Multiple Approaches

- What are different ways to solve this?
- What are the pros/cons of each?
- What are the trade-offs?
- Which approach is best?

### Evaluate Solutions

- Which is most maintainable?
- Which is most performant?
- Which is most testable?
- Which follows patterns?

### Choose Best Approach

- Select the best solution
- Document the reasoning
- Consider future implications
- Plan for edge cases

---

## Step 3: Implement with Care

### Follow Patterns

- Use existing patterns
- Follow architectural guidelines
- Match code style
- Use established conventions

### Add Error Handling

- Handle expected errors
- Handle unexpected errors
- Provide meaningful messages
- Log errors appropriately

### Consider Performance

- Is this efficient?
- Are there bottlenecks?
- Can this be optimized?
- Is caching needed?

### Document Complex Logic

- Add comments for complex code
- Explain "why" not "what"
- Document decisions
- Add examples if needed

---

## Step 4: Verify Thoroughly

### Test in Browser

- Start the application
- Navigate to feature
- Test functionality
- Check console logs
- Verify visual appearance

### Check Logs

**ALWAYS check stored logs from localStorage FIRST:**

1. **Check Stored Logs:**
   - Library logs: `LoggerService.getLogsFromLocalStorage()`
   - App logs: `LoggingService.getLogsFromLocalStorage()`
   - Full context is in localStorage (not console)

2. **Read Console Messages:**
   - Console output is minimal
   - Identify errors
   - Check warnings
   - Verify network requests

**See:** `.cursor/rules/development/log-analysis.mdc` for detailed workflow

### Verify Edge Cases

- Test boundary conditions
- Test empty states
- Test error scenarios
- Test rapid interactions

### Ensure Consistency

- Matches existing code
- Follows patterns
- Uses same conventions
- Consistent with previous work

---

## Step 5: Reflect and Improve

### Review What Worked

- What went well?
- What patterns helped?
- What was effective?

### Identify Improvements

- What could be better?
- What was inefficient?
- What was unclear?

### Document Learnings

- What was learned?
- What patterns emerged?
- What should be remembered?

---

## ‚ö° Quick Checks (Simple Tasks)

**For simple tasks (bug fixes, refactoring, small changes):**

- [ ] Problem understood (root cause identified)
- [ ] Solution is clear (matches existing patterns)
- [ ] Consistency checked (matches codebase)
- [ ] Tests planned/written

**Skip deep analysis for simple, well-understood changes.**

---

## üéØ Deep Thinking Checklist (Standard/Complex Tasks)

Before responding, ensure:

- [ ] Full context understood
- [ ] Root cause identified
- [ ] Multiple solutions considered
- [ ] Best solution chosen with reasoning
- [ ] Edge cases considered
- [ ] Error scenarios handled
- [ ] Performance implications evaluated
- [ ] Testing strategy defined
- [ ] Browser testing planned
- [ ] Log analysis planned

---

## üí≠ Thinking Prompts

### For Problem Understanding

- "What is the actual problem here?"
- "Why is this happening?"
- "What are all the factors involved?"
- "What am I missing?"

### For Solution Planning

- "What are different ways to solve this?"
- "What are the trade-offs?"
- "Which approach is most maintainable?"
- "What could go wrong?"

### For Implementation

- "Does this follow existing patterns?"
- "Is error handling complete?"
- "Is this performant?"
- "Is this testable?"

### For Verification

- "How will I test this?"
- "What could break?"
- "Are edge cases handled?"
- "Is this consistent?"

---

## üîÑ Iterative Thinking

### Think ‚Üí Plan ‚Üí Implement ‚Üí Verify ‚Üí Reflect

1. **Think** deeply about the problem
2. **Plan** the solution thoroughly
3. **Implement** with care
4. **Verify** comprehensively
5. **Reflect** and improve

### Don't Skip Steps

- ‚ùå Don't implement without thinking
- ‚ùå Don't skip planning
- ‚ùå Don't skip verification
- ‚ùå Don't skip reflection

---

## üìä Quality Indicators

### Good Thinking Shows:

- Clear problem understanding
- Multiple solutions considered
- Reasoning for choices
- Edge cases identified
- Error scenarios planned
- Testing strategy defined

### Poor Thinking Shows:

- Jumping to implementation
- Single solution considered
- No reasoning provided
- Edge cases ignored
- Error handling missing
- No testing plan

---

## ‚úÖ Deep Thinking Checklist

Before taking action:

- [ ] Problem fully understood
- [ ] Root cause identified
- [ ] Multiple approaches considered
- [ ] Best approach chosen with reasoning
- [ ] Edge cases planned
- [ ] Error scenarios planned
- [ ] Testing strategy defined
- [ ] Implementation planned
- [ ] Verification planned
- [ ] Reflection planned

---

---

## üéØ Thinking Depth Guidelines

### Simple Tasks (Quick Checks)

**For simple tasks (bug fixes, minor changes, standard patterns):**

1. ‚úÖ Understand the requirement
2. ‚úÖ Identify existing pattern to follow
3. ‚úÖ Implement following pattern
4. ‚úÖ Verify consistency

**Time:** 1-2 minutes of analysis

**Examples:**
- Fix typo
- Add simple property
- Standard component creation (follows BaseSectionComponent)
- Standard service creation (providedIn: 'root', inject())

### Moderate Tasks (Standard Process)

**For moderate tasks (features, refactoring, improvements):**

1. ‚úÖ Understand the requirement fully
2. ‚úÖ Identify root cause (if bug)
3. ‚úÖ Plan solution (consider 2-3 approaches)
4. ‚úÖ Choose best approach
5. ‚úÖ Implement
6. ‚úÖ Verify

**Time:** 5-10 minutes of planning

**Examples:**
- Add new feature following existing patterns
- Refactor component
- Add new section type
- Improve existing code

### Complex Tasks (Deep Analysis)

**For complex tasks (architecture changes, novel patterns, major features):**

1. ‚úÖ Understand problem deeply
2. ‚úÖ Identify root cause
3. ‚úÖ Consider multiple solutions (3-5 approaches)
4. ‚úÖ Evaluate trade-offs thoroughly
5. ‚úÖ Choose best approach with reasoning
6. ‚úÖ Plan implementation in detail
7. ‚úÖ Plan testing strategy
8. ‚úÖ Plan verification
9. ‚úÖ Consider edge cases
10. ‚úÖ Consider error scenarios

**Time:** 15-30 minutes of analysis

**Examples:**
- Major architecture change
- New pattern introduction
- Complex feature with multiple components
- Performance-critical code
- Security-sensitive code

**Remember:** Scale thinking depth by complexity. Don't overthink simple tasks, don't underthink complex ones.
