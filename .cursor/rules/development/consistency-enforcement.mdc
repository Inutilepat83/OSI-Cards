---
description: "Enforce consistency across code, behavior, and sessions"
priority: 0
---

# Consistency Enforcement

## üéØ Consistency Principles

**ALWAYS maintain consistency in:**
- Code style
- Architectural patterns
- Error handling
- Testing approaches
- Documentation style
- Naming conventions

---

## üìù Code Style Consistency

### Naming Conventions

**Services:**
- Class: `LoggerService`, `CardFacadeService` (PascalCase, *Service pattern)
- File: `logger.service.ts`, `card-facade.service.ts` (kebab-case)
- Variable: `loggerService`, `cardFacade` (camelCase)
- Always `providedIn: 'root'`

**Components:**
- Class: `InfoSectionComponent` (PascalCase, *SectionComponent pattern)
- File: `info-section.component.ts` (kebab-case)
- Selector: `app-*-section` for library sections, `osi-*` for main components
  - Library sections: `app-info-section`, `app-analytics-section`
  - Main components: `osi-cards`, `osi-cards-container`
  - Library components: `app-card-actions`, `app-section-renderer`

**Interfaces/Types:**
- Name: `CardSection`, `LogEntry` (PascalCase, no I prefix)
- File: `card.model.ts`, `log-entry.interface.ts` (kebab-case)
- Use `*.model.ts` for model files, `*.interface.ts` for interfaces
- See: `card.model.ts`, `section-design-params.model.ts` for examples

### Import Patterns

**Import order (consistent across codebase):**
1. Angular core imports (`@angular/core`, `@angular/common`)
2. Library imports (`@osi-cards/*` path aliases)
3. Relative imports (same directory or parent directories)
4. Third-party imports (rxjs, lucide-angular, etc.)

**Path aliases (use for library imports):**
- `@osi-cards/lib/*` - Library code
- `@osi-cards/sections` - Section components
- `@osi-cards/services` - Services
- `@osi-cards/utils` - Utilities
- `@osi-cards/models` - Models/types
- `@osi-cards/types` - Type definitions
- `@osi-cards/icons` - Icons
- `@osi-cards/themes` - Themes

**Example:**
```typescript
// Angular core
import { Component, inject, Input } from '@angular/core';
import { CommonModule } from '@angular/common';

// Library (path aliases)
import { CardSection, CardField } from '@osi-cards/models';
import { BaseSectionComponent } from '../base-section.component';

// Relative imports
import './analytics-section.scss';
```

**See:** `tsconfig.json` paths for all available aliases

### Code Structure

**Always follow existing patterns:**
- Same import order (Angular ‚Üí Library ‚Üí Relative)
- Same class structure
- Same method organization
- Same comment style

### Consistency Checklist

- [ ] Matches existing naming conventions
- [ ] Follows existing code structure
- [ ] Uses same import style
- [ ] Matches existing formatting
- [ ] Uses same comment style

---

## üèóÔ∏è Architectural Consistency

### Pattern Usage

**Always use established patterns:**
- Service Layer Pattern for services
- Component Pattern for components (standalone, OnPush)
- Facade Pattern for complex subsystems
- Observer Pattern for reactive code (RxJS)

### Dependency Injection

**Always use same approach:**
- `inject()` function (preferred)
- Constructor injection (alternative)
- Never manual instantiation

### Error Handling

**Always use same approach:**
- ErrorHandler for global errors
- ErrorBoundaryComponent for component errors
- ErrorTrackingService for logging
- User-friendly error messages

### Consistency Checklist

- [ ] Uses established patterns
- [ ] Follows architectural guidelines
- [ ] Matches existing implementations
- [ ] No new patterns without justification

---

## üîÑ Session Consistency

### Remember Context

**Within a session:**
- Remember previous decisions
- Maintain same approach
- Reference earlier work
- Avoid contradictions

### Decision Logging

**Document decisions:**
- Why this approach?
- What alternatives considered?
- What trade-offs made?
- What patterns followed?

### Consistency Checklist

- [ ] Consistent with previous work in session
- [ ] No contradictory approaches
- [ ] Decisions documented
- [ ] Patterns maintained

---

## üß™ Testing Consistency

### Test Structure

**Always use same structure:**
- Arrange-Act-Assert pattern
- Descriptive test names
- One assertion per test (when possible)
- Proper test organization

### Test Naming

**Always use same naming:**
- `describe('FeatureName', () => {})`
- `it('should do something specific', () => {})`
- Clear, descriptive names

### Mocking

**Always use same approach:**
- Mock external dependencies
- Use same mocking library
- Same mock structure
- Same setup/teardown

### Consistency Checklist

- [ ] Test structure matches existing tests
- [ ] Test naming follows conventions
- [ ] Mocking approach consistent
- [ ] Test organization matches

---

## üìö Documentation Consistency

### Code Comments

**Always use same style:**
- JSDoc for public APIs
- Inline comments for complex logic
- Explain "why" not "what"
- Same comment format

### Documentation Style

**Always use same style:**
- Same markdown format
- Same structure
- Same level of detail
- Same examples format

### Consistency Checklist

- [ ] Comment style matches
- [ ] Documentation format matches
- [ ] Examples format matches
- [ ] Level of detail consistent

---

## üîç Consistency Verification

### Before Committing

**Check consistency:**
- Code style matches
- Patterns match
- Naming matches
- Structure matches

### Code Review

**Review for consistency:**
- Does this match existing code?
- Are patterns followed?
- Is naming consistent?
- Is structure consistent?

### Consistency Checklist

- [ ] Code style consistent
- [ ] Patterns consistent
- [ ] Naming consistent
- [ ] Structure consistent
- [ ] Documentation consistent

---

## üö® Inconsistency Detection

### Red Flags

**Watch for:**
- Different naming conventions
- Different code structure
- Different patterns
- Different error handling
- Different testing approaches

### Fix Inconsistencies

**When found:**
- Identify the standard
- Update to match standard
- Document the change
- Verify consistency

---

## ‚úÖ Consistency Checklist

Before considering work complete:

- [ ] Code style matches existing
- [ ] Patterns match existing
- [ ] Naming matches existing
- [ ] Structure matches existing
- [ ] Error handling matches existing
- [ ] Testing matches existing
- [ ] Documentation matches existing
- [ ] Consistent with session work
- [ ] No contradictions

---

**Remember:** Consistency is critical for maintainability. Always match existing patterns and conventions.
