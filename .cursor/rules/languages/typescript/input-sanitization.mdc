---
description: "TypeScript input sanitization, XSS prevention, validation"
globs: ["**/*.ts", "**/*.tsx"]
---

# TypeScript Input Sanitization

## Angular Sanitization

### DomSanitizer

```typescript
import { DomSanitizer, SafeHtml, SafeUrl } from '@angular/platform-browser';

@Injectable()
export class SanitizationService {
  constructor(private sanitizer: DomSanitizer) {}

  sanitizeHtml(html: string): SafeHtml {
    return this.sanitizer.sanitize(SecurityContext.HTML, html);
  }

  sanitizeUrl(url: string): SafeUrl {
    return this.sanitizer.sanitize(SecurityContext.URL, url);
  }

  sanitizeStyle(style: string): SafeStyle {
    return this.sanitizer.sanitize(SecurityContext.STYLE, style);
  }
}
```

### Security Contexts

```typescript
enum SecurityContext {
  NONE = 0,
  HTML = 1,
  STYLE = 2,
  SCRIPT = 3,
  URL = 4,
  RESOURCE_URL = 5
}
```

## XSS Prevention

### Text Binding (Safe)

```typescript
// ✅ Safe - Angular escapes by default
<div>{{ userInput }}</div>
```

### HTML Binding (Use with Caution)

```typescript
// ⚠️ Dangerous - only use with sanitized content
<div [innerHTML]="sanitizedHtml"></div>

// Implementation
get sanitizedHtml(): SafeHtml {
  return this.sanitizer.sanitize(
    SecurityContext.HTML,
    this.userInput
  );
}
```

### URL Binding

```typescript
// ✅ Safe - Angular validates URLs
<a [href]="userUrl">Link</a>

// For untrusted URLs, sanitize first
get safeUrl(): SafeUrl {
  return this.sanitizer.sanitize(SecurityContext.URL, this.userUrl);
}
```

## Input Validation

### Email Validation

```typescript
function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// Or use validator library
import { isEmail } from 'validator';

const isValid = isEmail(userInput);
```

### URL Validation

```typescript
function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

// Check for safe protocols
function isSafeUrl(url: string): boolean {
  try {
    const parsed = new URL(url);
    return ['http:', 'https:'].includes(parsed.protocol);
  } catch {
    return false;
  }
}
```

### HTML Sanitization

```typescript
import DOMPurify from 'dompurify';

function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p'],
    ALLOWED_ATTR: ['href']
  });
}
```

## SQL Injection Prevention

### TypeORM

```typescript
// ✅ Safe - TypeORM uses parameterized queries
const user = await userRepository.findOne({
  where: { email: userEmail }
});

// ✅ Safe - Query builder with parameters
const users = await userRepository
  .createQueryBuilder('user')
  .where('user.email = :email', { email: userEmail })
  .getMany();
```

### Raw Queries

```typescript
// ✅ Safe - use parameters
await dataSource.query(
  'SELECT * FROM users WHERE email = $1',
  [userEmail]
);

// ❌ Dangerous - string concatenation
await dataSource.query(
  `SELECT * FROM users WHERE email = '${userEmail}'`
);
```

## Path Traversal Prevention

### File Path Validation

```typescript
import * as path from 'path';

function getSafeFilePath(userInput: string, baseDir: string): string | null {
  // Resolve to absolute path
  const resolvedPath = path.resolve(baseDir, userInput);

  // Ensure it's within base directory
  const basePath = path.resolve(baseDir);
  if (!resolvedPath.startsWith(basePath)) {
    return null; // Path traversal attempt
  }

  return resolvedPath;
}
```

## Command Injection Prevention

### Avoid Shell Execution

```typescript
// ❌ Dangerous
import { exec } from 'child_process';
exec(`git clone ${repoUrl}`);

// ✅ Safe - use execFile with array
import { execFile } from 'child_process';
execFile('git', ['clone', repoUrl], (error, stdout, stderr) => {
  // Handle result
});
```

## File Upload Security

### File Type Validation

```typescript
function isValidFileType(file: File, allowedTypes: string[]): boolean {
  return allowedTypes.includes(file.type);
}

function isValidFileExtension(filename: string, allowedExtensions: string[]): boolean {
  const ext = filename.split('.').pop()?.toLowerCase();
  return ext ? allowedExtensions.includes(ext) : false;
}

// Validate both MIME type and extension
function validateFile(file: File): boolean {
  const allowedMimeTypes = ['image/jpeg', 'image/png', 'application/pdf'];
  const allowedExtensions = ['jpg', 'jpeg', 'png', 'pdf'];

  return (
    isValidFileType(file, allowedMimeTypes) &&
    isValidFileExtension(file.name, allowedExtensions)
  );
}
```

### File Size Validation

```typescript
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

function isValidFileSize(file: File): boolean {
  return file.size <= MAX_FILE_SIZE;
}
```

## Sanitization Utilities

### String Sanitization

```typescript
function sanitizeString(input: string): string {
  return input
    .replace(/[<>]/g, '') // Remove angle brackets
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .trim();
}

function escapeHtml(unsafe: string): string {
  return unsafe
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}
```

## Best Practices

### ✅ Do

- Validate all inputs at boundaries
- Use Angular's built-in sanitization
- Use parameterized queries
- Validate file uploads
- Sanitize HTML if you must allow it
- Use whitelist validation
- Escape output appropriately

### ❌ Don't

- Trust client-side validation alone
- Use string concatenation for queries
- Allow arbitrary HTML/JavaScript
- Execute shell commands with user input
- Trust file extensions
- Skip server-side validation

**See also:** `patterns/input-sanitization.mdc`, `security.mdc`, `validation.mdc`
