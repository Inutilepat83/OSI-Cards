---
description: "Input validation, class-validator, Zod, validation patterns"
globs: ["**/*.ts", "**/*.tsx"]
---

# TypeScript Validation

## Validation Libraries

### class-validator (NestJS, TypeORM)

```typescript
import { IsEmail, IsString, MinLength, MaxLength } from 'class-validator';

export class CreateUserDto {
  @IsEmail({}, { message: 'Email must be a valid email address' })
  email: string;

  @IsString()
  @MinLength(3, { message: 'Name must be at least 3 characters' })
  @MaxLength(50, { message: 'Name must not exceed 50 characters' })
  name: string;

  @IsString()
  @MinLength(8, { message: 'Password must be at least 8 characters' })
  password: string;
}
```

### Zod (Schema Validation)

```typescript
import { z } from 'zod';

const CreateUserSchema = z.object({
  email: z.string().email('Invalid email address'),
  name: z.string().min(3, 'Name must be at least 3 characters')
    .max(50, 'Name must not exceed 50 characters'),
  password: z.string().min(8, 'Password must be at least 8 characters')
});

type CreateUserDto = z.infer<typeof CreateUserSchema>;

function validateCreateUser(data: unknown): Result<CreateUserDto, ValidationError> {
  const result = CreateUserSchema.safeParse(data);
  if (result.success) {
    return success(result.data);
  }
  return failure(new ValidationError(result.error.errors));
}
```

## Validation Strategies

### Validate in Angular Forms

```typescript
import { FormBuilder, Validators } from '@angular/forms';

@Component({...})
export class UserFormComponent {
  private readonly fb = inject(FormBuilder);
  
  form = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    name: ['', [Validators.required, Validators.minLength(3)]],
    password: ['', [Validators.required, Validators.minLength(8)]],
  });
  
  onSubmit(): void {
    if (this.form.valid) {
      // Process form data
    }
  }
}
```

### Validate in Services

```typescript
@Injectable({ providedIn: 'root' })
export class UserService {
  createUser(data: CreateUserData): Observable<User> {
    // Validate input
    if (!this.isValidEmail(data.email)) {
      throw new ValidationError('Invalid email');
    }
    // ... create user
  }
}
```

### Custom Validators

```typescript
// class-validator
@ValidatorConstraint({ name: 'isStrongPassword', async: false })
export class IsStrongPasswordConstraint implements ValidatorConstraintInterface {
  validate(password: string): boolean {
    return /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/.test(password);
  }

  defaultMessage(): string {
    return 'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character';
  }
}

// Usage
export class CreateUserDto {
  @IsStrongPassword()
  password: string;
}
```

## Validation Patterns

### Type Guards

```typescript
function isCreateUserDto(obj: unknown): obj is CreateUserDto {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'email' in obj &&
    'name' in obj &&
    'password' in obj &&
    typeof (obj as any).email === 'string' &&
    typeof (obj as any).name === 'string' &&
    typeof (obj as any).password === 'string'
  );
}
```

### Schema Validation

```typescript
function validateSchema<T>(
  schema: z.ZodSchema<T>,
  data: unknown
): Result<T, ValidationError> {
  const result = schema.safeParse(data);
  if (result.success) {
    return success(result.data);
  }
  return failure(new ValidationError(result.error.errors));
}
```

## Angular Forms Validation

### Reactive Forms

```typescript
export class UserFormComponent {
  form = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    name: ['', [Validators.required, Validators.minLength(3)]],
    password: ['', [Validators.required, Validators.minLength(8)]]
  });

  constructor(private fb: FormBuilder) {}

  onSubmit(): void {
    if (this.form.valid) {
      const userData = this.form.value;
      // Process form
    } else {
      this.markFormGroupTouched(this.form);
    }
  }
}
```

### Custom Validators

```typescript
export function passwordStrengthValidator(control: AbstractControl): ValidationErrors | null {
  const password = control.value;
  if (!password) return null;

  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumeric = /[0-9]/.test(password);
  const hasSpecialChar = /[@$!%*?&]/.test(password);

  const valid = hasUpperCase && hasLowerCase && hasNumeric && hasSpecialChar;
  return valid ? null : { passwordStrength: true };
}
```

## Validation Error Handling

### Error Format

```typescript
interface ValidationError {
  field: string;
  message: string;
  code: string;
}

class ValidationException extends Error {
  constructor(
    public readonly errors: ValidationError[],
    message = 'Validation failed'
  ) {
    super(message);
    this.name = 'ValidationException';
  }
}
```

### Error Response (RFC 7807)

```typescript
function formatValidationError(errors: ValidationError[], instance: string) {
  return {
    type: 'https://example.com/problems/validation-error',
    title: 'Validation Error',
    status: 400,
    detail: 'The request contains invalid data',
    instance,
    errors: errors.reduce((acc, error) => {
      if (!acc[error.field]) {
        acc[error.field] = [];
      }
      acc[error.field].push(error.message);
      return acc;
    }, {} as Record<string, string[]>)
  };
}
```

## Best Practices

### ✅ Do

- Validate at API boundaries
- Use validation libraries
- Provide clear error messages
- Validate both client and server side
- Use type-safe validation
- Return structured error responses

### ❌ Don't

- Trust client-side validation alone
- Skip server-side validation
- Expose internal validation details
- Use generic error messages
- Validate in multiple places unnecessarily

**See also:** `security.mdc`, `error-handling.mdc`, `angular-components.mdc`
