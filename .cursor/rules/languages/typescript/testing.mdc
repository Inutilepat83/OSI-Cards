---
description: "TypeScript testing with Jasmine/Karma, Angular testing, Playwright E2E"
globs: ["**/*.spec.ts", "**/*.test.ts"]
---

# TypeScript Testing

## Testing Frameworks

### Jasmine + Karma (Unit Testing)

- Jasmine testing framework
- Karma test runner
- Angular Testing Utilities (TestBed)
- Component testing
- Service testing

### Playwright (E2E Testing)

- End-to-end testing
- Browser automation
- User workflow testing
- Cross-browser testing

### Angular Testing

- Jasmine + Karma for unit tests
- Playwright for E2E tests
- Angular Testing Utilities (TestBed)
- Component testing
- Service testing

## Test Structure

### Describe Blocks

```typescript
describe('UserService', () => {
  describe('getUser', () => {
    it('should return user when found', () => {});
    it('should return null when not found', () => {});
  });

  describe('createUser', () => {
    it('should create user successfully', () => {});
    it('should return error when email exists', () => {});
  });
});
```

### AAA Pattern

```typescript
it('should return user when found', async () => {
  // Arrange
  const userId = '123';
  const expectedUser: User = { id: userId, name: 'John' };
  const mockService = jasmine.createSpyObj('UserService', ['getUser']);
  mockService.getUser.and.returnValue(of(expectedUser));
  
  // Act
  const result = await mockService.getUser(userId).toPromise();

  // Assert
  expect(result).toEqual(expectedUser);
  expect(mockService.getUser).toHaveBeenCalledWith(userId);
});
```

## Mocking

### Mock Services (Jasmine)

```typescript
// Jasmine spy objects
const mockService = jasmine.createSpyObj('MyService', ['method1', 'method2']);
mockService.method1.and.returnValue(value);
mockService.method1.and.returnValue(of(observableValue)); // For observables

// Spies
const spy = jasmine.createSpy('methodName');
spy.and.returnValue(value);
spy.and.throwError(new Error('Error'));
```

### Mock Services in TestBed

```typescript
const mockService = jasmine.createSpyObj('MyService', ['getData']);

TestBed.configureTestingModule({
  providers: [
    { provide: MyService, useValue: mockService }
  ]
});
```

### HTTP Mocking

```typescript
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';

TestBed.configureTestingModule({
  imports: [HttpClientTestingModule]
});

const httpMock = TestBed.inject(HttpTestingController);
const req = httpMock.expectOne('/api/data');
req.flush(mockData);
```

## Angular Component Testing (Jasmine + Karma)

### Test Setup

```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { UserComponent } from './user.component';

describe('UserComponent', () => {
  let component: UserComponent;
  let fixture: ComponentFixture<UserComponent>;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [UserComponent], // Standalone component
    }).compileComponents();
    
    fixture = TestBed.createComponent(UserComponent);
    component = fixture.componentInstance;
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
```

### Testing Component Interactions

```typescript
it('should display user name', () => {
  component.user = { id: '1', name: 'John' };
  fixture.detectChanges();

  const element = fixture.nativeElement;
  expect(element.querySelector('.user-name').textContent).toBe('John');
});

it('should call service on button click', () => {
  const service = TestBed.inject(UserService);
  spyOn(service, 'loadUser');

  const button = fixture.nativeElement.querySelector('button');
  button.click();

  expect(service.loadUser).toHaveBeenCalled();
});
```

## Async Testing

### Promises

```typescript
it('should handle async operation', async () => {
  const result = await service.getUser('123');
  expect(result).toBeDefined();
});
```

### Observables (RxJS)

```typescript
it('should handle observable', (done) => {
  service.getUser$('123').subscribe({
    next: (user) => {
      expect(user).toBeDefined();
      done();
    },
    error: (error) => {
      fail(error);
      done();
    }
  });
});

// Or use async/await with firstValueFrom
it('should handle observable', async () => {
  const user = await firstValueFrom(service.getUser$('123'));
  expect(user).toBeDefined();
});
```

## Test Utilities

### Custom Matchers

```typescript
expect.extend({
  toBeValidUser(received: User) {
    const pass = received.id && received.email;
    return {
      message: () => `expected ${received} to be a valid user`,
      pass
    };
  }
});
```

### Test Helpers

```typescript
function createMockUser(overrides?: Partial<User>): User {
  return {
    id: '1',
    email: 'test@example.com',
    name: 'Test User',
    ...overrides
  };
}
```

## Test Coverage

### Coverage Goals

- Aim for 80%+ coverage
- Focus on business logic
- Test edge cases
- Test error scenarios

### Coverage Commands

```bash
# Jasmine + Karma (Angular)
npm test -- --code-coverage

# Or
ng test --code-coverage
```

## Best Practices

### ✅ Do

- Write tests before implementation (TDD)
- Use descriptive test names
- Keep tests independent
- Mock external dependencies
- Test one thing per test
- Use AAA pattern

### ❌ Don't

- Test implementation details
- Use real external services
- Share state between tests
- Write tests that depend on each other
- Test framework code
- Ignore flaky tests

**See also:** `patterns/testing.mdc`, `code-quality.mdc`, `error-handling.mdc`
