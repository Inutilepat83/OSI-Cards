# ============================================================================
# CODING STANDARDS & RULES
# ============================================================================
# This file defines specific coding rules and standards that complement
# the design patterns in architect.yaml. Rules are more granular and
# enforce specific coding practices.

rules:
  # ============================================================================
  # TYPESCRIPT STANDARDS
  # ============================================================================
  - pattern: "**/*.ts"
    description: "TypeScript coding standards"
    must_do:
      - rule: "Use explicit return types for public methods"
        codeExample: |
          // ✅ Correct
          public getUser(id: string): Observable<User> {
            return this.api.get(`/users/${id}`);
          }

          // ❌ Wrong
          public getUser(id: string) {
            return this.api.get(`/users/${id}`);
          }

      - rule: "Use named exports instead of default exports"
        codeExample: |
          // ✅ Correct
          export class UserService { }

          // ❌ Wrong
          export default class UserService { }

      - rule: "Avoid 'any' type without justification"
        codeExample: |
          // ✅ Correct
          function processData(data: unknown): ProcessedData {
            if (isValidData(data)) {
              return transform(data);
            }
            throw new Error('Invalid data');
          }

          // ❌ Wrong
          function processData(data: any): any {
            return transform(data);
          }

      - rule: "Use readonly for immutable properties"
        codeExample: |
          // ✅ Correct
          export class Config {
            readonly apiUrl: string;
            readonly timeout: number;
          }

          // ❌ Wrong
          export class Config {
            apiUrl: string;
            timeout: number;
          }

    must_not_do:
      - rule: "No console.log in production code"
        codeExample: |
          // ❌ Wrong
          console.log('User data:', user);

          // ✅ Correct - Use logger service
          this.logger.debug('User data:', user);

      - rule: "No magic numbers or strings"
        codeExample: |
          // ❌ Wrong
          if (status === 200) { }
          setTimeout(() => {}, 5000);

          // ✅ Correct
          const HTTP_OK = 200;
          const TIMEOUT_MS = 5000;
          if (status === HTTP_OK) { }
          setTimeout(() => {}, TIMEOUT_MS);

  # ============================================================================
  # SERVICE LAYER RULES
  # ============================================================================
  - pattern: "**/services/**/*.ts"
    description: "Service layer coding standards"
    must_do:
      - rule: "Services must extend BaseService or implement lifecycle hooks"
        codeExample: |
          // ✅ Correct
          @Injectable({ providedIn: 'root' })
          export class UserService extends BaseService {
            constructor() {
              super();
            }
          }

      - rule: "Use inject() function for dependency injection"
        codeExample: |
          // ✅ Correct
          @Injectable({ providedIn: 'root' })
          export class UserService {
            private api = inject(ApiService);
            private logger = inject(LoggingService);
          }

      - rule: "Handle errors with ErrorTrackingService"
        codeExample: |
          // ✅ Correct
          getUser(id: string): Observable<User> {
            return this.api.get(`/users/${id}`).pipe(
              catchError((error) => {
                this.errorTracking.trackError(error, { context: 'UserService.getUser' });
                return throwError(() => error);
              })
            );
          }

    must_not_do:
      - rule: "No direct database access in services"
        codeExample: |
          // ❌ Wrong
          import { db } from '../database';
          async getUser(id: string) {
            return db.query('SELECT * FROM users WHERE id = ?', [id]);
          }

          // ✅ Correct - Use repository/provider
          constructor(private userRepo: IUserRepository) {}
          async getUser(id: string) {
            return this.userRepo.findById(id);
          }

      - rule: "No manual service instantiation"
        codeExample: |
          // ❌ Wrong
          const userService = new UserService();

          // ✅ Correct - Use dependency injection
          private userService = inject(UserService);

  # ============================================================================
  # COMPONENT RULES
  # ============================================================================
  - pattern: "**/components/**/*.component.ts"
    description: "Component coding standards"
    must_do:
      - rule: "Components must be standalone"
        codeExample: |
          // ✅ Correct
          @Component({
            selector: 'app-user',
            standalone: true,
            imports: [CommonModule],
            changeDetection: ChangeDetectionStrategy.OnPush
          })
          export class UserComponent { }

      - rule: "Use OnPush change detection"
        codeExample: |
          // ✅ Correct
          @Component({
            changeDetection: ChangeDetectionStrategy.OnPush
          })

      - rule: "Clean up subscriptions in ngOnDestroy"
        codeExample: |
          // ✅ Correct
          export class UserComponent implements OnDestroy {
            private destroyRef = inject(DestroyRef);

            ngOnInit() {
              this.dataService.getData()
                .pipe(takeUntilDestroyed(this.destroyRef))
                .subscribe(data => this.data = data);
            }
          }

    must_not_do:
      - rule: "No business logic in components"
        codeExample: |
          // ❌ Wrong
          onSave() {
            // Complex business logic here
            const processed = this.processData(this.form.value);
            const validated = this.validate(processed);
            // ...
          }

          // ✅ Correct - Delegate to service
          onSave() {
            this.userService.saveUser(this.form.value).subscribe();
          }

      - rule: "No direct DOM manipulation"
        codeExample: |
          // ❌ Wrong
          @ViewChild('element') element!: ElementRef;
          ngAfterViewInit() {
            this.element.nativeElement.style.display = 'none';
          }

          // ✅ Correct - Use Renderer2
          constructor(private renderer: Renderer2) {}
          ngAfterViewInit() {
            this.renderer.setStyle(this.element.nativeElement, 'display', 'none');
          }

  # ============================================================================
  # RXJS RULES
  # ============================================================================
  - pattern: "**/*.ts"
    description: "RxJS observable patterns"
    must_do:
      - rule: "Use takeUntilDestroyed for component subscriptions"
        codeExample: |
          // ✅ Correct
          export class UserComponent {
            private destroyRef = inject(DestroyRef);

            loadData() {
              this.dataService.getData()
                .pipe(takeUntilDestroyed(this.destroyRef))
                .subscribe();
            }
          }

      - rule: "Use async pipe in templates when possible"
        codeExample: |
          // ✅ Correct
          // Component
          users$ = this.userService.getUsers();

          // Template
          <div *ngFor="let user of users$ | async">{{ user.name }}</div>

    must_not_do:
      - rule: "No unsubscribed observables"
        codeExample: |
          // ❌ Wrong
          ngOnInit() {
            this.dataService.getData().subscribe();
            // Memory leak - subscription never cleaned up
          }

          // ✅ Correct
          ngOnInit() {
            this.dataService.getData()
              .pipe(takeUntilDestroyed(this.destroyRef))
              .subscribe();
          }

      - rule: "No nested subscriptions"
        codeExample: |
          // ❌ Wrong
          this.userService.getUser(id).subscribe(user => {
            this.orderService.getOrders(user.id).subscribe(orders => {
              // Nested subscription
            });
          });

          // ✅ Correct - Use operators
          this.userService.getUser(id).pipe(
            switchMap(user => this.orderService.getOrders(user.id))
          ).subscribe(orders => {
            // Single subscription
          });

  # ============================================================================
  # UTILITY RULES
  # ============================================================================
  - pattern: "**/utils/**/*.ts"
    description: "Utility function standards"
    must_do:
      - rule: "Utilities must be pure functions"
        codeExample: |
          // ✅ Correct
          export function formatDate(date: Date): string {
            return date.toISOString().split('T')[0];
          }

    must_not_do:
      - rule: "No side effects in utilities"
        codeExample: |
          // ❌ Wrong
          export function formatDate(date: Date): string {
            console.log('Formatting date'); // Side effect
            return date.toISOString().split('T')[0];
          }

      - rule: "No service dependencies in utilities"
        codeExample: |
          // ❌ Wrong
          import { LoggingService } from '../services/logging.service';
          export function formatDate(date: Date): string {
            // Utility depends on service
          }

  # ============================================================================
  # MODEL RULES
  # ============================================================================
  - pattern: "**/models/**/*.ts"
    description: "Model and type definitions"
    must_do:
      - rule: "Use interfaces for data contracts"
        codeExample: |
          // ✅ Correct
          export interface User {
            id: string;
            name: string;
            email: string;
          }

      - rule: "Use type guards for runtime validation"
        codeExample: |
          // ✅ Correct
          export function isUser(obj: unknown): obj is User {
            return (
              typeof obj === 'object' &&
              obj !== null &&
              'id' in obj &&
              'name' in obj &&
              'email' in obj
            );
          }

    must_not_do:
      - rule: "No 'any' types in models"
        codeExample: |
          // ❌ Wrong
          export interface User {
            id: any;
            data: any;
          }

          // ✅ Correct
          export interface User {
            id: string;
            data: Record<string, unknown>;
          }

  # ============================================================================
  # ERROR HANDLING RULES
  # ============================================================================
  - pattern: "**/*.ts"
    description: "Error handling standards"
    must_do:
      - rule: "Always handle or propagate errors"
        codeExample: |
          // ✅ Correct
          getUser(id: string): Observable<User> {
            return this.api.get(`/users/${id}`).pipe(
              catchError((error) => {
                this.errorTracking.trackError(error);
                return throwError(() => error);
              })
            );
          }

    must_not_do:
      - rule: "No silent error swallowing"
        codeExample: |
          // ❌ Wrong
          getUser(id: string): Observable<User> {
            return this.api.get(`/users/${id}`).pipe(
              catchError(() => of(null)) // Silent failure
            );
          }

          // ✅ Correct
          getUser(id: string): Observable<User> {
            return this.api.get(`/users/${id}`).pipe(
              catchError((error) => {
                this.logger.error('Failed to get user', error);
                return throwError(() => error);
              })
            );
          }









