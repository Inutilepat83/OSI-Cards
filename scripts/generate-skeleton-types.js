#!/usr/bin/env node

/**
 * Generate Skeleton Types
 *
 * Scans the sections directory and generates skeleton type definitions.
 * This ensures the skeleton component stays in sync with available sections.
 *
 * Run: npm run generate:skeleton-types
 */

const fs = require('fs');
const path = require('path');

const ROOT_DIR = path.join(__dirname, '..');
const SECTIONS_DIR = path.join(
  ROOT_DIR,
  'projects',
  'osi-cards-lib',
  'src',
  'lib',
  'components',
  'sections'
);
const OUTPUT_PATH = path.join(
  ROOT_DIR,
  'projects',
  'osi-cards-lib',
  'src',
  'lib',
  'components',
  'section-skeleton',
  'skeleton-types.generated.ts'
);

const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  yellow: '\x1b[33m',
};

function log(msg, color = colors.reset) {
  console.log(`${color}${msg}${colors.reset}`);
}

/**
 * Extract section type from directory/file name
 * e.g., "analytics-section" -> "analytics"
 * e.g., "info-section.component.ts" -> "info"
 */
function extractSectionType(name) {
  return name
    .replace(/-section$/, '')
    .replace(/-section\.component\.ts$/, '')
    .replace(/\.component\.ts$/, '');
}

/**
 * Check if a path is a section directory or file
 */
function isSectionEntry(entry, fullPath) {
  // Skip non-section files
  const skipPatterns = [
    'index.ts',
    'base-section',
    'abstract-section',
    '.spec.ts',
    '.html',
    '.scss',
  ];

  if (skipPatterns.some((pattern) => entry.includes(pattern))) {
    return false;
  }

  const stats = fs.statSync(fullPath);

  // It's a section if it's a directory ending with -section
  if (stats.isDirectory() && entry.endsWith('-section')) {
    return true;
  }

  // Or if it's a component file directly in the sections folder
  if (stats.isFile() && entry.endsWith('-section.component.ts')) {
    return true;
  }

  return false;
}

/**
 * Scan sections directory and extract all section types
 */
function scanSectionsDirectory() {
  const entries = fs.readdirSync(SECTIONS_DIR);
  const sectionTypes = new Set();

  for (const entry of entries) {
    const fullPath = path.join(SECTIONS_DIR, entry);

    if (isSectionEntry(entry, fullPath)) {
      const sectionType = extractSectionType(entry);
      if (sectionType && sectionType !== 'fallback') {
        sectionTypes.add(sectionType);
      }
    }
  }

  // Sort alphabetically for consistent output
  return Array.from(sectionTypes).sort();
}

/**
 * Generate the TypeScript file content
 */
function generateTypeScriptContent(sectionTypes) {
  const timestamp = new Date().toISOString();

  return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * Generated by: scripts/generate-skeleton-types.js
 * Source: projects/osi-cards-lib/src/lib/components/sections/
 * Run: npm run generate:skeleton-types
 * Generated at: ${timestamp}
 */

/**
 * All section types discovered from the sections directory.
 * This is the single source of truth for available section types.
 */
export const ALL_SECTION_TYPES = [
${sectionTypes.map((type) => `  '${type}',`).join('\n')}
] as const;

/**
 * Type representing all available section types
 */
export type SectionType = (typeof ALL_SECTION_TYPES)[number];

/**
 * Total number of section types available
 */
export const SECTION_TYPE_COUNT = ${sectionTypes.length};

/**
 * Check if a string is a valid section type
 */
export function isValidSectionType(type: string): type is SectionType {
  return (ALL_SECTION_TYPES as readonly string[]).includes(type.toLowerCase());
}

/**
 * Get all section types as an array (for runtime use)
 */
export function getAllSectionTypes(): string[] {
  return [...ALL_SECTION_TYPES];
}

/**
 * Metadata about the generated types
 */
export const SKELETON_TYPES_META = {
  generatedAt: '${timestamp}',
  sourceDirectory: 'projects/osi-cards-lib/src/lib/components/sections/',
  totalTypes: ${sectionTypes.length},
};
`;
}

/**
 * Main generation function
 */
function generateSkeletonTypes() {
  log('\nü¶¥ Generating Skeleton Types', colors.cyan);
  log('‚ïê'.repeat(50), colors.cyan);

  // Check if sections directory exists
  if (!fs.existsSync(SECTIONS_DIR)) {
    log(`  ‚úó Sections directory not found: ${SECTIONS_DIR}`, colors.yellow);
    process.exit(1);
  }

  // Scan directory
  const sectionTypes = scanSectionsDirectory();
  log(`  üìÇ Scanned: ${SECTIONS_DIR}`, colors.blue);
  log(`  üìä Found ${sectionTypes.length} section types:`, colors.blue);

  // Log found types
  sectionTypes.forEach((type) => {
    log(`     - ${type}`, colors.reset);
  });

  // Generate content
  const content = generateTypeScriptContent(sectionTypes);

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write file
  fs.writeFileSync(OUTPUT_PATH, content, 'utf8');

  log(`  ‚úì Generated: ${OUTPUT_PATH}`, colors.green);
  log('‚ïê'.repeat(50) + '\n', colors.cyan);

  return sectionTypes;
}

// Run generator
if (require.main === module) {
  try {
    generateSkeletonTypes();
  } catch (error) {
    console.error('Error generating skeleton types:', error);
    process.exit(1);
  }
}

module.exports = { generateSkeletonTypes, scanSectionsDirectory };



