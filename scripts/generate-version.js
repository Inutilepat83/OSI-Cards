#!/usr/bin/env node

/**
 * Generate version.ts file for runtime version access
 *
 * This script delegates to version-sync.js for actual version management.
 * It reads from version.config.json as the single source of truth.
 *
 * Usage:
 *   node scripts/generate-version.js
 *   npm run version:generate
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const ROOT_DIR = path.join(__dirname, '..');
const VERSION_CONFIG = path.join(ROOT_DIR, 'version.config.json');
const VERSION_FILE = path.join(ROOT_DIR, 'src', 'version.ts');
const LIB_VERSION_FILE = path.join(ROOT_DIR, 'projects', 'osi-cards-lib', 'src', 'lib', 'version.ts');

/**
 * Get git info
 */
function getGitInfo() {
  try {
    const hash = execSync('git rev-parse --short HEAD', { encoding: 'utf8' }).trim();
    const branch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();
    return { hash, branch };
  } catch {
    return { hash: 'unknown', branch: 'unknown' };
  }
}

/**
 * Load version from config or package.json
 */
function loadVersion() {
  // Try version.config.json first (source of truth)
  if (fs.existsSync(VERSION_CONFIG)) {
    try {
      const config = JSON.parse(fs.readFileSync(VERSION_CONFIG, 'utf8'));
      return config.version;
    } catch (e) {
      console.warn('Could not read version.config.json:', e.message);
    }
  }

  // Fallback to package.json
  const packageJson = path.join(ROOT_DIR, 'package.json');
  try {
    const pkg = JSON.parse(fs.readFileSync(packageJson, 'utf8'));
    return pkg.version || '0.0.0';
  } catch {
    return '0.0.0';
  }
}

/**
 * Generate version.ts file
 */
function generateVersionFile() {
  const version = loadVersion();
  const git = getGitInfo();
  const buildDate = new Date().toISOString();

  const content = `/**
 * Auto-generated version file
 * Do not edit manually - generated by scripts/generate-version.js
 *
 * Source of truth: version.config.json
 * Last synced: ${buildDate}
 */

export const VERSION = '${version}';
export const BUILD_DATE = '${buildDate}';
export const BUILD_HASH = '${git.hash}';
export const BUILD_BRANCH = '${git.branch}';

export interface VersionInfo {
  version: string;
  buildDate: string;
  buildHash: string;
  buildBranch: string;
}

export const VERSION_INFO: VersionInfo = {
  version: VERSION,
  buildDate: BUILD_DATE,
  buildHash: BUILD_HASH,
  buildBranch: BUILD_BRANCH,
};

/**
 * Get formatted version string
 * @example "1.5.2 (main@abc1234)"
 */
export function getVersionString(): string {
  return \`\${VERSION} (\${BUILD_BRANCH}@\${BUILD_HASH})\`;
}

/**
 * Get short version for display
 * @example "v1.5.2"
 */
export function getShortVersion(): string {
  return \`v\${VERSION}\`;
}

/**
 * Get full build info for debugging
 */
export function getBuildInfo(): string {
  return \`OSI Cards \${VERSION} | Built: \${new Date(BUILD_DATE).toLocaleDateString()} | \${BUILD_BRANCH}@\${BUILD_HASH}\`;
}

/**
 * Check if current build is a production build
 */
export function isProductionBuild(): boolean {
  return BUILD_BRANCH === 'main' || BUILD_BRANCH === 'master';
}

/**
 * Check if current build is a prerelease
 */
export function isPrerelease(): boolean {
  return VERSION.includes('-');
}
`;

  // Ensure src directory exists
  const srcDir = path.dirname(VERSION_FILE);
  if (!fs.existsSync(srcDir)) {
    fs.mkdirSync(srcDir, { recursive: true });
  }

  fs.writeFileSync(VERSION_FILE, content, 'utf8');
  console.log(`✓ Generated version.ts (${version} @ ${git.branch}/${git.hash})`);

  // Also generate version file for library
  const libSrcDir = path.dirname(LIB_VERSION_FILE);
  if (!fs.existsSync(libSrcDir)) {
    fs.mkdirSync(libSrcDir, { recursive: true });
  }

  fs.writeFileSync(LIB_VERSION_FILE, content, 'utf8');
  console.log(`✓ Generated library version.ts (${version} @ ${git.branch}/${git.hash})`);
}

// Run if called directly
if (require.main === module) {
  generateVersionFile();
}

module.exports = { generateVersionFile, loadVersion, getGitInfo };
















