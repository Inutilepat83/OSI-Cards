#!/usr/bin/env node
/**
 * Regenerate ALL documentation page components to use DocPageComponent
 * This removes NgDoc dependency for Angular 20 compatibility
 */

const fs = require('fs');
const path = require('path');

const DOCS_DIR = path.join(__dirname, '../src/app/features/documentation');

// Comprehensive page content templates
const PAGE_CONTENTS = {
  // Library usage
  'library-usage': `# Library Usage Guide

Complete guide on how to use OSI Cards library in your Angular application.

## Basic Usage

### 1. Import the Component

\`\`\`typescript
import { Component } from '@angular/core';
import { AICardRendererComponent, AICardConfig } from 'osi-cards-lib';

@Component({
  selector: 'app-my-component',
  standalone: true,
  imports: [AICardRendererComponent],
  template: \\\`
    <app-ai-card-renderer [cardConfig]="cardConfig"></app-ai-card-renderer>
  \\\`
})
export class MyComponent {
  cardConfig: AICardConfig = {
    cardTitle: 'My Card',
    sections: [
      {
        title: 'Overview',
        type: 'info',
        fields: [
          { label: 'Name', value: 'Example' },
          { label: 'Status', value: 'Active' }
        ]
      }
    ]
  };
}
\`\`\`

## Handling Events

\`\`\`typescript
@Component({
  template: \\\`
    <app-ai-card-renderer
      [cardConfig]="card"
      (sectionEvent)="onSectionEvent($event)"
      (actionEvent)="onActionEvent($event)">
    </app-ai-card-renderer>
  \\\`
})
export class CardViewerComponent {
  onSectionEvent(event: SectionEvent) {
    console.log('Section event:', event);
  }
  
  onActionEvent(event: ActionEvent) {
    switch(event.action.type) {
      case 'mail':
        window.location.href = \\\`mailto:\\\${event.action.email}\\\`;
        break;
      case 'website':
        window.open(event.action.url, '_blank');
        break;
    }
  }
}
\`\`\`

## Using MasonryGrid

For displaying multiple cards:

\`\`\`typescript
import { MasonryGridComponent } from 'osi-cards-lib';

@Component({
  imports: [MasonryGridComponent],
  template: \\\`
    <app-masonry-grid [cards]="cards" [columns]="3"></app-masonry-grid>
  \\\`
})
export class CardsPageComponent {
  cards: AICardConfig[] = [];
}
\`\`\`

## Streaming Support

For progressive card rendering:

\`\`\`typescript
import { OSICardsStreamingService } from 'osi-cards-lib';

@Component({...})
export class StreamingComponent {
  private streaming = inject(OSICardsStreamingService);
  
  async loadCard() {
    const stream = this.streaming.createStream();
    
    stream.updates$.subscribe(update => {
      this.cardConfig = update.card;
    });
    
    await stream.start(jsonChunks);
  }
}
\`\`\`

See [Streaming Documentation](/docs/streaming/overview) for more details.
`,

  'llm-integration': `# LLM Integration

Guide for integrating OSI Cards with Large Language Models.

## Overview

OSI Cards is designed to render structured data generated by LLMs. This guide covers best practices for prompt engineering and handling LLM responses.

## Prompt Template

Include the schema in your LLM prompt:

\`\`\`typescript
const systemPrompt = \\\`
You are a helpful assistant that generates structured card data.
Return JSON matching the following TypeScript interface:

interface AICardConfig {
  cardTitle: string;
  sections: CardSection[];
}

interface CardSection {
  title: string;
  type: 'info' | 'analytics' | 'contact-card' | 'list' | 'chart';
  fields?: Array<{ label: string; value: string }>;
  metrics?: Array<{ label: string; value: string; trend?: 'up' | 'down' }>;
  items?: Array<{ title: string; description?: string }>;
}

Return ONLY valid JSON, no markdown or explanation.
\\\`;
\`\`\`

## Streaming Integration

Handle streaming responses from LLMs:

\`\`\`typescript
async function streamCard(prompt: string) {
  const response = await fetch('/api/chat', {
    method: 'POST',
    body: JSON.stringify({ prompt }),
    headers: { 'Content-Type': 'application/json' }
  });
  
  const reader = response.body.getReader();
  let buffer = '';
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    buffer += new TextDecoder().decode(value);
    
    try {
      const partialCard = JSON.parse(buffer);
      streamingService.updateCard(partialCard);
    } catch {
      // Buffer incomplete, continue reading
    }
  }
}
\`\`\`

## Validation

Always validate LLM output:

\`\`\`typescript
import { isValidCardConfig, sanitizeCardConfig } from 'osi-cards-lib';

function processLLMResponse(json: string): AICardConfig | null {
  try {
    const data = JSON.parse(json);
    
    if (!isValidCardConfig(data)) {
      console.error('Invalid card config from LLM');
      return null;
    }
    
    return sanitizeCardConfig(data);
  } catch (error) {
    console.error('Failed to parse LLM response:', error);
    return null;
  }
}
\`\`\`

## Error Handling

\`\`\`typescript
const fallbackCard: AICardConfig = {
  cardTitle: 'Error',
  sections: [{
    title: 'Unable to generate card',
    type: 'info',
    fields: [{ label: 'Status', value: 'Please try again' }]
  }]
};

streamingService.streamCard(prompt).pipe(
  catchError(error => {
    console.error('Streaming error:', error);
    return of(fallbackCard);
  })
).subscribe(card => this.cardConfig = card);
\`\`\`

## Best Practices

1. **Use structured output modes** - Many LLMs support JSON mode
2. **Include examples** - Few-shot prompting improves quality
3. **Validate aggressively** - Never trust LLM output blindly
4. **Handle partial JSON** - Streaming may produce incomplete JSON
5. **Set timeouts** - Prevent hanging on slow responses
`,

  // Schemas
  'schemas/ai-card-config': `# AICardConfig Schema

The root configuration interface for OSI Cards.

## Interface Definition

\`\`\`typescript
interface AICardConfig {
  /** Unique identifier for the card */
  id?: string;
  
  /** Card title displayed in the header */
  cardTitle: string;
  
  /** Optional subtitle */
  subtitle?: string;
  
  /** Array of sections to display */
  sections: CardSection[];
  
  /** Card metadata */
  metadata?: {
    createdAt?: string;
    updatedAt?: string;
    source?: string;
    confidence?: number;
  };
  
  /** Card-level actions */
  actions?: CardAction[];
  
  /** Theme configuration */
  theme?: {
    variant?: 'default' | 'compact' | 'expanded';
    accentColor?: string;
  };
}
\`\`\`

## Required Properties

| Property | Type | Description |
|----------|------|-------------|
| cardTitle | string | Main title displayed in card header |
| sections | CardSection[] | Array of section configurations |

## Optional Properties

| Property | Type | Description |
|----------|------|-------------|
| id | string | Unique identifier (auto-generated if not provided) |
| subtitle | string | Secondary title text |
| metadata | object | Additional card information |
| actions | CardAction[] | Global card actions |
| theme | object | Theme customization |

## Example

\`\`\`typescript
const config: AICardConfig = {
  id: 'card-001',
  cardTitle: 'Acme Corporation',
  subtitle: 'Company Overview',
  sections: [
    {
      title: 'Basic Info',
      type: 'info',
      fields: [
        { label: 'Industry', value: 'Technology' },
        { label: 'Founded', value: '2010' }
      ]
    },
    {
      title: 'Key Metrics',
      type: 'analytics',
      metrics: [
        { label: 'Revenue', value: '$1.2M', trend: 'up' },
        { label: 'Employees', value: '150' }
      ]
    }
  ],
  metadata: {
    source: 'CRM',
    confidence: 0.95
  }
};
\`\`\`

## Related

- [CardSection](/docs/schemas/card-section)
- [CardAction](/docs/schemas/card-action)
`,

  'schemas/card-section': `# CardSection Schema

Base interface for all section types.

## Interface Definition

\`\`\`typescript
interface CardSection {
  /** Section identifier */
  id?: string;
  
  /** Section title */
  title: string;
  
  /** Section type determines rendering */
  type: SectionType;
  
  /** Whether section is collapsible */
  collapsible?: boolean;
  
  /** Initial collapsed state */
  collapsed?: boolean;
  
  /** Section-specific properties vary by type */
  [key: string]: any;
}

type SectionType = 
  | 'info'
  | 'analytics'
  | 'contact-card'
  | 'network-card'
  | 'map'
  | 'financials'
  | 'event'
  | 'list'
  | 'chart'
  | 'product'
  | 'solutions'
  | 'overview'
  | 'quotation'
  | 'text-reference'
  | 'brand-colors'
  | 'news'
  | 'social-media';
\`\`\`

## Common Properties

| Property | Type | Description |
|----------|------|-------------|
| title | string | Section heading |
| type | SectionType | Determines which component renders the section |
| collapsible | boolean | Whether user can collapse section |
| collapsed | boolean | Initial collapsed state |

## Type-Specific Properties

Each section type has its own required and optional properties. See individual section type documentation for details.

## Example

\`\`\`typescript
const infoSection: CardSection = {
  title: 'Company Details',
  type: 'info',
  fields: [
    { label: 'Name', value: 'Acme Corp' },
    { label: 'Industry', value: 'Technology' }
  ]
};

const analyticsSection: CardSection = {
  title: 'Key Metrics',
  type: 'analytics',
  metrics: [
    { label: 'Revenue', value: '$10M', trend: 'up' }
  ]
};
\`\`\`
`,

  'schemas/card-field': `# CardField Schema

Schema for individual fields in info-style sections.

## Interface Definition

\`\`\`typescript
interface CardField {
  /** Field label/name */
  label: string;
  
  /** Field value */
  value: string | number | boolean;
  
  /** Optional icon name */
  icon?: string;
  
  /** Optional link URL */
  link?: string;
  
  /** Value format hint */
  format?: 'text' | 'number' | 'currency' | 'date' | 'email' | 'phone';
  
  /** Additional CSS class */
  className?: string;
}
\`\`\`

## Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| label | string | Yes | Field name displayed on left |
| value | string/number/boolean | Yes | Field value displayed on right |
| icon | string | No | Lucide icon name |
| link | string | No | Makes value clickable |
| format | string | No | Formatting hint for value |

## Examples

\`\`\`typescript
// Basic field
{ label: 'Name', value: 'Acme Corp' }

// With icon
{ label: 'Email', value: 'info@acme.com', icon: 'mail' }

// With link
{ label: 'Website', value: 'acme.com', link: 'https://acme.com' }

// With format
{ label: 'Revenue', value: 1000000, format: 'currency' }
\`\`\`

## Usage in Sections

\`\`\`typescript
const section = {
  title: 'Contact Information',
  type: 'info',
  fields: [
    { label: 'Email', value: 'contact@example.com', icon: 'mail', format: 'email' },
    { label: 'Phone', value: '+1 555-0123', icon: 'phone', format: 'phone' },
    { label: 'Website', value: 'example.com', icon: 'globe', link: 'https://example.com' }
  ]
};
\`\`\`
`,

  'schemas/card-item': `# CardItem Schema

Schema for items in list-style sections.

## Interface Definition

\`\`\`typescript
interface CardItem {
  /** Item identifier */
  id?: string;
  
  /** Item title */
  title: string;
  
  /** Item description */
  description?: string;
  
  /** Icon name */
  icon?: string;
  
  /** Image URL */
  imageUrl?: string;
  
  /** Badge text */
  badge?: string;
  
  /** Badge variant */
  badgeVariant?: 'default' | 'success' | 'warning' | 'error';
  
  /** Item actions */
  actions?: CardAction[];
  
  /** Additional data */
  data?: Record<string, any>;
}
\`\`\`

## Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| title | string | Yes | Main item text |
| description | string | No | Secondary text |
| icon | string | No | Lucide icon name |
| imageUrl | string | No | Item image |
| badge | string | No | Status badge text |
| actions | CardAction[] | No | Item-level actions |

## Example

\`\`\`typescript
const listSection = {
  title: 'Features',
  type: 'list',
  items: [
    {
      title: 'Real-time Streaming',
      description: 'Progressive card rendering with live updates',
      icon: 'zap',
      badge: 'New',
      badgeVariant: 'success'
    },
    {
      title: 'Type Safety',
      description: 'Full TypeScript support',
      icon: 'shield-check'
    },
    {
      title: 'Accessibility',
      description: 'WCAG 2.1 compliant',
      icon: 'accessibility'
    }
  ]
};
\`\`\`
`,

  'schemas/card-action': `# CardAction Schema

Schema for interactive actions on cards and sections.

## Interface Definition

\`\`\`typescript
type CardAction = 
  | MailAction
  | WebsiteAction
  | AgentAction
  | QuestionAction
  | CustomAction;

interface MailAction {
  type: 'mail';
  label: string;
  email: string;
  subject?: string;
  body?: string;
  icon?: string;
}

interface WebsiteAction {
  type: 'website';
  label: string;
  url: string;
  target?: '_blank' | '_self';
  icon?: string;
}

interface AgentAction {
  type: 'agent';
  label: string;
  action: string;
  payload?: Record<string, any>;
  icon?: string;
}

interface QuestionAction {
  type: 'question';
  label: string;
  question: string;
  context?: Record<string, any>;
  icon?: string;
}

interface CustomAction {
  type: 'custom';
  label: string;
  handler: string;
  data?: Record<string, any>;
  icon?: string;
}
\`\`\`

## Action Types

### Mail Action

Opens email client:

\`\`\`typescript
{
  type: 'mail',
  label: 'Contact Sales',
  email: 'sales@company.com',
  subject: 'Inquiry',
  icon: 'mail'
}
\`\`\`

### Website Action

Opens URL:

\`\`\`typescript
{
  type: 'website',
  label: 'Visit Website',
  url: 'https://example.com',
  target: '_blank',
  icon: 'external-link'
}
\`\`\`

### Agent Action

Triggers AI agent:

\`\`\`typescript
{
  type: 'agent',
  label: 'Learn More',
  action: 'getDetails',
  payload: { entityId: '123' },
  icon: 'bot'
}
\`\`\`

### Question Action

Asks follow-up question:

\`\`\`typescript
{
  type: 'question',
  label: 'Tell me more',
  question: 'What are the pricing options?',
  icon: 'message-circle'
}
\`\`\`
`,

  'schemas/email-config': `# EmailConfig Schema

Configuration for email-related functionality.

## Interface Definition

\`\`\`typescript
interface EmailConfig {
  /** Email address */
  email: string;
  
  /** Email subject line */
  subject?: string;
  
  /** Email body template */
  body?: string;
  
  /** CC recipients */
  cc?: string[];
  
  /** BCC recipients */
  bcc?: string[];
}
\`\`\`

## Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| email | string | Yes | Primary recipient |
| subject | string | No | Pre-filled subject |
| body | string | No | Pre-filled body text |
| cc | string[] | No | Carbon copy recipients |
| bcc | string[] | No | Blind carbon copy |

## Example Usage

\`\`\`typescript
const mailAction: CardAction = {
  type: 'mail',
  label: 'Contact Support',
  email: 'support@company.com',
  subject: 'Support Request - {{cardTitle}}',
  body: 'Hi,\\n\\nI have a question about...'
};
\`\`\`

## Template Variables

You can use template variables in subject and body:

- \\\`{{cardTitle}}\\\` - Card title
- \\\`{{sectionTitle}}\\\` - Section title
- \\\`{{fieldName}}\\\` - Any field value
`,

  'schemas/type-aliases': `# Type Aliases Reference

Common type aliases used throughout OSI Cards.

## Section Types

\`\`\`typescript
type SectionType = 
  | 'info'
  | 'analytics'
  | 'contact-card'
  | 'network-card'
  | 'map'
  | 'financials'
  | 'event'
  | 'list'
  | 'chart'
  | 'product'
  | 'solutions'
  | 'overview'
  | 'quotation'
  | 'text-reference'
  | 'brand-colors'
  | 'news'
  | 'social-media';
\`\`\`

## Action Types

\`\`\`typescript
type ActionType = 'mail' | 'website' | 'agent' | 'question' | 'custom';
\`\`\`

## Trend Direction

\`\`\`typescript
type TrendDirection = 'up' | 'down' | 'neutral';
\`\`\`

## Chart Types

\`\`\`typescript
type ChartType = 'line' | 'bar' | 'pie' | 'doughnut' | 'radar' | 'polarArea';
\`\`\`

## Theme Variants

\`\`\`typescript
type ThemeVariant = 'default' | 'compact' | 'expanded';
type ColorScheme = 'light' | 'dark' | 'auto';
\`\`\`

## Format Types

\`\`\`typescript
type FormatType = 'text' | 'number' | 'currency' | 'percentage' | 'date' | 'email' | 'phone' | 'url';
\`\`\`

## Event Types

\`\`\`typescript
type CardEventType = 
  | 'card:load'
  | 'card:update'
  | 'section:render'
  | 'section:click'
  | 'field:click'
  | 'action:trigger';
\`\`\`

## Streaming States

\`\`\`typescript
type StreamingState = 'idle' | 'streaming' | 'paused' | 'completed' | 'error';
\`\`\`
`,

  // Streaming docs
  'streaming/overview': `# Streaming Overview

Progressive card rendering with real-time updates.

## What is Streaming?

Streaming allows cards to render progressively as data arrives, providing immediate feedback while processing LLM responses.

## Key Benefits

1. **Immediate Feedback** - Users see content as it generates
2. **Better UX** - No waiting for complete response
3. **Error Recovery** - Partial data is better than nothing
4. **LLM Integration** - Native support for streaming APIs

## Basic Usage

\`\`\`typescript
import { OSICardsStreamingService } from 'osi-cards-lib';

@Component({...})
export class MyComponent {
  private streaming = inject(OSICardsStreamingService);
  cardConfig = signal<AICardConfig | null>(null);
  
  async streamCard() {
    const stream = this.streaming.createStream({
      debounceMs: 50,
      maxUpdatesPerSecond: 20
    });
    
    stream.updates$.subscribe(update => {
      this.cardConfig.set(update.card);
    });
    
    // Feed JSON chunks from your LLM
    for await (const chunk of llmResponse) {
      stream.pushChunk(chunk);
    }
    
    stream.complete();
  }
}
\`\`\`

## Streaming Flow

1. Create stream instance
2. Subscribe to updates
3. Push chunks as they arrive
4. Card renders progressively
5. Complete or error the stream

## Related

- [Configuration](/docs/streaming/config)
- [State Management](/docs/streaming/state)
- [Error Handling](/docs/streaming/error-handling)
`,

  'streaming/config': `# Streaming Configuration

Configure streaming behavior for optimal performance.

## StreamingConfig Interface

\`\`\`typescript
interface StreamingConfig {
  /** Debounce time for updates (ms) */
  debounceMs?: number;
  
  /** Maximum updates per second */
  maxUpdatesPerSecond?: number;
  
  /** Buffer size for chunks */
  bufferSize?: number;
  
  /** Enable progressive parsing */
  progressiveParsing?: boolean;
  
  /** Timeout for stream completion (ms) */
  timeout?: number;
  
  /** Retry configuration */
  retry?: {
    maxAttempts: number;
    delayMs: number;
  };
}
\`\`\`

## Default Configuration

\`\`\`typescript
const defaults: StreamingConfig = {
  debounceMs: 50,
  maxUpdatesPerSecond: 30,
  bufferSize: 1024 * 64,  // 64KB
  progressiveParsing: true,
  timeout: 60000,  // 1 minute
  retry: {
    maxAttempts: 3,
    delayMs: 1000
  }
};
\`\`\`

## Usage

\`\`\`typescript
const stream = streamingService.createStream({
  debounceMs: 100,  // Slower updates for mobile
  maxUpdatesPerSecond: 15,
  timeout: 30000
});
\`\`\`

## Performance Tuning

- **High-frequency updates**: Lower debounceMs, higher maxUpdatesPerSecond
- **Battery-conscious**: Higher debounceMs, lower update rate
- **Large payloads**: Increase bufferSize
`,

  'streaming/state': `# Streaming State Management

Understanding and managing streaming state.

## StreamingState Interface

\`\`\`typescript
interface StreamingState {
  /** Current state */
  status: 'idle' | 'streaming' | 'paused' | 'completed' | 'error';
  
  /** Percentage complete (0-100) */
  progress: number;
  
  /** Bytes received */
  bytesReceived: number;
  
  /** Chunks processed */
  chunksProcessed: number;
  
  /** Current card state */
  currentCard: AICardConfig | null;
  
  /** Last error if any */
  error: Error | null;
  
  /** Timestamp of last update */
  lastUpdate: Date;
}
\`\`\`

## State Transitions

\`\`\`
idle → streaming → completed
         ↓ ↑
        paused
         ↓
        error
\`\`\`

## Observing State

\`\`\`typescript
const stream = streamingService.createStream();

// Full state
stream.state$.subscribe(state => {
  console.log('Status:', state.status);
  console.log('Progress:', state.progress);
});

// Just the card
stream.card$.subscribe(card => {
  this.cardConfig = card;
});

// Errors
stream.error$.subscribe(error => {
  console.error('Stream error:', error);
});
\`\`\`

## State Control

\`\`\`typescript
// Pause streaming
stream.pause();

// Resume streaming
stream.resume();

// Cancel streaming
stream.cancel();

// Force completion
stream.complete();
\`\`\`
`,

  'streaming/card-updates': `# Card Updates

Handling incremental card updates during streaming.

## CardUpdate Interface

\`\`\`typescript
interface CardUpdate {
  /** Update type */
  type: 'initial' | 'incremental' | 'complete';
  
  /** Current card state */
  card: AICardConfig;
  
  /** Changed sections */
  changedSections?: string[];
  
  /** New sections added */
  newSections?: CardSection[];
  
  /** Timestamp */
  timestamp: Date;
}
\`\`\`

## Update Types

### Initial Update
First card structure with title:

\`\`\`typescript
{
  type: 'initial',
  card: {
    cardTitle: 'Company Overview',
    sections: []
  }
}
\`\`\`

### Incremental Update
Partial section data:

\`\`\`typescript
{
  type: 'incremental',
  card: { /* updated card */ },
  changedSections: ['section-1'],
  newSections: [{ title: 'New Section', type: 'info', ... }]
}
\`\`\`

### Complete Update
Final card state:

\`\`\`typescript
{
  type: 'complete',
  card: { /* final card */ }
}
\`\`\`

## Handling Updates

\`\`\`typescript
stream.updates$.pipe(
  filter(update => update.type === 'incremental'),
  tap(update => {
    // Track changed sections
    update.changedSections?.forEach(id => {
      console.log('Section updated:', id);
    });
  })
).subscribe();
\`\`\`
`,

  'streaming/progressive-rendering': `# Progressive Rendering

How OSI Cards renders content progressively during streaming.

## Overview

Progressive rendering shows content as soon as it's available:

1. Card header appears first
2. Sections render as they're parsed
3. Fields populate incrementally
4. Animations smooth the transitions

## Render Phases

### Phase 1: Skeleton
Before any data:
- Card skeleton with placeholder
- Loading indicator

### Phase 2: Header
Title parsed:
- Card title renders
- Subtitle if available
- Skeleton for sections

### Phase 3: Section Structure
Section titles parsed:
- Section headers appear
- Content placeholders

### Phase 4: Content
Fields/items parsed:
- Actual content fills in
- Progressive reveal animation

### Phase 5: Complete
All data received:
- Final render pass
- Loading indicator removed

## Component Usage

\`\`\`html
<app-ai-card-renderer
  [cardConfig]="cardConfig"
  [streaming]="isStreaming"
  [showSkeleton]="!hasContent">
</app-ai-card-renderer>
\`\`\`

## CSS Transitions

The library uses CSS transitions for smooth rendering:

\`\`\`css
.section-enter {
  animation: fadeSlideIn 0.3s ease-out;
}

.field-enter {
  animation: fadeIn 0.2s ease-out;
}
\`\`\`

## Performance

- Sections render independently
- Virtual scrolling for long cards
- Debounced re-renders
- CSS containment for isolation
`,

  'streaming/lifecycle': `# Streaming Lifecycle

Understanding the streaming lifecycle hooks.

## Lifecycle Events

\`\`\`typescript
stream.on('start', () => {
  console.log('Stream started');
});

stream.on('chunk', (chunk) => {
  console.log('Chunk received:', chunk.length, 'bytes');
});

stream.on('update', (update) => {
  console.log('Card updated:', update.type);
});

stream.on('pause', () => {
  console.log('Stream paused');
});

stream.on('resume', () => {
  console.log('Stream resumed');
});

stream.on('complete', (card) => {
  console.log('Stream complete:', card.cardTitle);
});

stream.on('error', (error) => {
  console.error('Stream error:', error);
});

stream.on('cancel', () => {
  console.log('Stream cancelled');
});
\`\`\`

## Lifecycle Flow

\`\`\`
create() → start → chunk* → update* → complete
                      ↓
                    error
                      ↓
                   cancel
\`\`\`

## Using with RxJS

\`\`\`typescript
stream.lifecycle$.pipe(
  filter(event => event.type === 'complete'),
  take(1)
).subscribe(({ card }) => {
  this.saveCard(card);
});
\`\`\`
`,

  'streaming/error-handling': `# Streaming Error Handling

Handling errors during card streaming.

## Error Types

\`\`\`typescript
type StreamingErrorType = 
  | 'PARSE_ERROR'      // Invalid JSON
  | 'TIMEOUT'          // Stream timeout
  | 'NETWORK_ERROR'    // Connection lost
  | 'VALIDATION_ERROR' // Invalid card data
  | 'CANCELLED'        // User cancelled
  | 'UNKNOWN';         // Other errors
\`\`\`

## Handling Errors

\`\`\`typescript
stream.error$.subscribe(error => {
  switch (error.type) {
    case 'PARSE_ERROR':
      // Try to salvage partial data
      this.cardConfig = stream.getPartialCard();
      break;
      
    case 'TIMEOUT':
      // Retry or show timeout message
      this.retryStream();
      break;
      
    case 'NETWORK_ERROR':
      // Show offline state
      this.showOfflineMessage();
      break;
      
    default:
      this.showError(error.message);
  }
});
\`\`\`

## Recovery Strategies

### Retry with Backoff

\`\`\`typescript
const stream = streamingService.createStream({
  retry: {
    maxAttempts: 3,
    delayMs: 1000,
    backoffMultiplier: 2
  }
});
\`\`\`

### Fallback Card

\`\`\`typescript
stream.complete$.pipe(
  catchError(error => {
    return of(this.fallbackCard);
  })
).subscribe(card => {
  this.cardConfig = card;
});
\`\`\`

### Partial Data

\`\`\`typescript
if (stream.hasPartialData()) {
  const partial = stream.getPartialCard();
  // Render what we have
  this.cardConfig = partial;
}
\`\`\`

## Best Practices

1. Always provide error feedback to users
2. Log errors for debugging
3. Consider retry strategies
4. Show partial data when possible
5. Provide clear recovery actions
`
};

// Convert path to title
function pathToTitle(p) {
  return p
    .split('/')
    .pop()
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// Convert path to component name  
function pathToComponentName(p) {
  const parts = p.split('/');
  const name = parts.map(part => 
    part.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('')
  ).join('');
  return name + 'PageComponent';
}

// Generate import path depth
function getImportDepth(pagePath) {
  const depth = pagePath.split('/').length;
  return '../'.repeat(depth);
}

// Generate page component content
function generatePageComponent(pagePath) {
  const title = pathToTitle(pagePath);
  const componentName = pathToComponentName(pagePath);
  const importPath = getImportDepth(pagePath);
  let content = PAGE_CONTENTS[pagePath];
  
  if (!content) {
    content = `# ${title}

Documentation for ${title}.

## Overview

This section covers ${title.toLowerCase()} functionality in OSI Cards.

## Usage

See the examples and API reference below for implementation details.

## Related

- [Getting Started](/docs/getting-started)
- [Best Practices](/docs/best-practices)
`;
  }
  
  // Escape backticks and template literal syntax
  const escapedContent = content
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${');

  return `import { Component, ChangeDetectionStrategy } from '@angular/core';
import { DocPageComponent } from '${importPath}doc-page.component';

const pageContent = \`${escapedContent}\`;

@Component({
  selector: 'app-${pagePath.replace(/\//g, '-')}-page',
  standalone: true,
  imports: [DocPageComponent],
  template: \`<app-doc-page [content]="content"></app-doc-page>\`,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ${componentName} {
  content = pageContent;
}

export default ${componentName};
`;
}

// All pages to regenerate
const ALL_PAGES = [
  // Top level
  'library-usage',
  'llm-integration',
  
  // Schemas
  'schemas/ai-card-config',
  'schemas/card-section',
  'schemas/card-field',
  'schemas/card-item',
  'schemas/card-action',
  'schemas/email-config',
  'schemas/type-aliases',
  
  // Streaming
  'streaming/overview',
  'streaming/config',
  'streaming/state',
  'streaming/card-updates',
  'streaming/progressive-rendering',
  'streaming/lifecycle',
  'streaming/error-handling',
  
  // Services
  'services/streaming-service',
  'services/event-middleware-service',
  'services/section-plugin-registry',
  'services/theme-service',
  'services/animation-orchestrator',
  'services/icon-service',
  'services/magnetic-tilt-service',
  'services/section-normalization',
  'services/layout-worker-service',
  'services/section-utils-service',
  
  // Components
  'components/ai-card-renderer',
  'components/section-renderer',
  'components/masonry-grid',
  'components/card-skeleton',
  'components/card-streaming-indicator',
  'components/card-actions',
  'components/card-header',
  'components/card-preview',
  'components/osi-cards',
  'components/osi-cards-container',
  
  // Integration
  'integration/quick-start',
  'integration/npm-installation',
  'integration/angular-18',
  'integration/angular-20',
  'integration/standalone-components',
  'integration/module-based',
  'integration/lazy-loading',
  'integration/ssr',
  'integration/pwa',
  'integration/dependencies',
  'integration/llm-overview',
  'integration/prompt-engineering',
  'integration/card-generation-prompt',
  'integration/streaming-responses',
  'integration/websocket-integration',
  'integration/agent-systems',
  'integration/error-recovery',
  'integration/rate-limiting',
  'integration/card-validation',
  'integration/json-schema-llm',
  
  // Advanced
  'advanced/theming-overview',
  'advanced/css-properties',
  'advanced/theme-presets',
  'advanced/custom-sections',
  'advanced/event-middleware',
  'advanced/performance',
  'advanced/accessibility',
  'advanced/i18n',
  'advanced/security',
  'advanced/error-patterns',
  
  // Utilities
  'utilities/card-utils',
  'utilities/card-type-guards',
  'utilities/resolve-section-type',
  'utilities/is-valid-section-type',
  'utilities/ensure-card-ids',
  'utilities/sanitize-card-config',
  
  // Library docs
  'library-docs/agentic-flow',
  'library-docs/services',
  'library-docs/events',
  'library-docs/theming'
];

function main() {
  console.log('Regenerating all documentation pages...\n');
  
  let count = 0;
  
  for (const pagePath of ALL_PAGES) {
    const fullPath = path.join(DOCS_DIR, pagePath, 'page.component.ts');
    const dir = path.dirname(fullPath);
    
    // Ensure directory exists
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    // Generate component content
    const componentContent = generatePageComponent(pagePath);
    
    // Write file
    fs.writeFileSync(fullPath, componentContent, 'utf-8');
    console.log(`✓ ${pagePath}/page.component.ts`);
    count++;
  }
  
  console.log(`\nRegenerated ${count} page components.`);
}

main();




