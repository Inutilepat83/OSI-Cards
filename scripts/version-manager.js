#!/usr/bin/env node

/**
 * Version Manager Script
 * Automates semantic versioning, changelog updates, and git tagging
 * 
 * Usage:
 *   npm run version:patch   - Bump patch version (1.0.0 -> 1.0.1)
 *   npm run version:minor   - Bump minor version (1.0.0 -> 1.1.0)
 *   npm run version:major   - Bump major version (1.0.0 -> 2.0.0)
 *   npm run version:prerelease - Create prerelease version (1.0.0 -> 1.0.1-rc.0)
 *   npm run version:sync    - Sync versions between main and library
 *   npm run version:show    - Show current version
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const ROOT_PACKAGE_JSON = path.join(__dirname, '..', 'package.json');
const LIB_PACKAGE_JSON = path.join(__dirname, '..', 'projects', 'osi-cards-lib', 'package.json');
const CHANGELOG_PATH = path.join(__dirname, '..', 'CHANGELOG.md');
const VERSION_FILE = path.join(__dirname, '..', 'src', 'version.ts');

/**
 * Parse version string into components
 */
function parseVersion(version) {
  const match = version.match(/^(\d+)\.(\d+)\.(\d+)(?:-([\w.]+))?(?:\+([\w.]+))?$/);
  if (!match) {
    throw new Error(`Invalid version format: ${version}`);
  }
  return {
    major: parseInt(match[1], 10),
    minor: parseInt(match[2], 10),
    patch: parseInt(match[3], 10),
    prerelease: match[4] || null,
    build: match[5] || null
  };
}

/**
 * Format version components into version string
 */
function formatVersion(components) {
  let version = `${components.major}.${components.minor}.${components.patch}`;
  if (components.prerelease) {
    version += `-${components.prerelease}`;
  }
  if (components.build) {
    version += `+${components.build}`;
  }
  return version;
}

/**
 * Bump version based on type
 */
function bumpVersion(currentVersion, type) {
  const components = parseVersion(currentVersion);
  
  switch (type) {
    case 'major':
      components.major += 1;
      components.minor = 0;
      components.patch = 0;
      components.prerelease = null;
      break;
    case 'minor':
      components.minor += 1;
      components.patch = 0;
      components.prerelease = null;
      break;
    case 'patch':
      components.patch += 1;
      components.prerelease = null;
      break;
    case 'prerelease':
      if (components.prerelease) {
        // Increment prerelease number (e.g., rc.0 -> rc.1)
        const prereleaseMatch = components.prerelease.match(/^(\w+)\.(\d+)$/);
        if (prereleaseMatch) {
          const prereleaseNum = parseInt(prereleaseMatch[2], 10) + 1;
          components.prerelease = `${prereleaseMatch[1]}.${prereleaseNum}`;
        } else {
          components.prerelease = `${components.prerelease}.0`;
        }
      } else {
        // Start new prerelease
        components.patch += 1;
        components.prerelease = 'rc.0';
      }
      break;
    default:
      throw new Error(`Unknown version type: ${type}`);
  }
  
  return formatVersion(components);
}

/**
 * Read package.json
 */
function readPackageJson(filePath) {
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

/**
 * Write package.json
 */
function writePackageJson(filePath, packageJson) {
  fs.writeFileSync(filePath, JSON.stringify(packageJson, null, 2) + '\n', 'utf8');
}

/**
 * Update version in package.json
 */
function updatePackageVersion(filePath, newVersion) {
  const packageJson = readPackageJson(filePath);
  packageJson.version = newVersion;
  writePackageJson(filePath, packageJson);
  return packageJson;
}

/**
 * Generate version.ts file for runtime access
 */
function generateVersionFile(version, buildDate) {
  const buildHash = getGitHash();
  const buildBranch = getGitBranch();
  
  const content = `/**
 * Auto-generated version file
 * Do not edit manually - this file is generated by version-manager.js
 * Updated during build process
 */

export const VERSION = '${version}';
export const BUILD_DATE = '${buildDate}';
export const BUILD_HASH = '${buildHash}';
export const BUILD_BRANCH = '${buildBranch}';

export interface VersionInfo {
  version: string;
  buildDate: string;
  buildHash: string;
  buildBranch: string;
}

export const VERSION_INFO: VersionInfo = {
  version: VERSION,
  buildDate: BUILD_DATE,
  buildHash: BUILD_HASH,
  buildBranch: BUILD_BRANCH
};

/**
 * Get formatted version string
 */
export function getVersionString(): string {
  return \`\${VERSION} (\${BUILD_BRANCH}@\${BUILD_HASH})\`;
}

/**
 * Check if current build is a production build
 */
export function isProductionBuild(): boolean {
  return BUILD_BRANCH === 'main' || BUILD_BRANCH === 'master';
}
`;
  
  fs.writeFileSync(VERSION_FILE, content, 'utf8');
  console.log(`‚úì Generated ${VERSION_FILE}`);
}

/**
 * Get git branch name
 */
function getGitBranch() {
  try {
    return execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();
  } catch {
    return 'unknown';
  }
}

/**
 * Get git commit hash
 */
function getGitHash() {
  try {
    return execSync('git rev-parse --short HEAD', { encoding: 'utf8' }).trim();
  } catch {
    return 'unknown';
  }
}

/**
 * Update CHANGELOG.md with new version
 */
function updateChangelog(newVersion, type) {
  if (!fs.existsSync(CHANGELOG_PATH)) {
    console.warn('CHANGELOG.md not found, skipping changelog update');
    return;
  }

  let changelog = fs.readFileSync(CHANGELOG_PATH, 'utf8');
  const today = new Date().toISOString().split('T')[0];
  
  // Replace [Unreleased] with new version
  const unreleasedSection = changelog.match(/## \[Unreleased\]([\s\S]*?)(?=## \[|$)/);
  if (unreleasedSection) {
    const unreleasedContent = unreleasedSection[1].trim();
    const versionSection = `## [${newVersion}] - ${today}\n\n${unreleasedContent}\n\n`;
    changelog = changelog.replace(/## \[Unreleased\]/, `## [Unreleased]\n\n### Added\n- TBD\n\n## [${newVersion}] - ${today}`);
  } else {
    // Add new version section if [Unreleased] doesn't exist
    const versionSection = `## [${newVersion}] - ${today}\n\n### Added\n- TBD\n\n`;
    changelog = `# Changelog\n\n${versionSection}\n${changelog.replace(/^# Changelog\n\n/, '')}`;
  }
  
  fs.writeFileSync(CHANGELOG_PATH, changelog, 'utf8');
  console.log(`‚úì Updated CHANGELOG.md`);
}

/**
 * Create git tag
 */
function createGitTag(version, message) {
  try {
    const tagName = `v${version}`;
    execSync(`git tag -a ${tagName} -m "${message || `Release ${version}`}"`, { stdio: 'inherit' });
    console.log(`‚úì Created git tag: ${tagName}`);
    return tagName;
  } catch (error) {
    console.warn('Failed to create git tag:', error.message);
    return null;
  }
}

/**
 * Sync versions between main and library package.json
 */
function syncVersions() {
  const rootPackage = readPackageJson(ROOT_PACKAGE_JSON);
  const libPackage = readPackageJson(LIB_PACKAGE_JSON);
  
  // Use library version as source of truth (it's more mature)
  const version = libPackage.version || rootPackage.version;
  
  if (rootPackage.version !== version) {
    updatePackageVersion(ROOT_PACKAGE_JSON, version);
    console.log(`‚úì Synced root package.json to ${version}`);
  }
  
  if (libPackage.version !== version) {
    updatePackageVersion(LIB_PACKAGE_JSON, version);
    console.log(`‚úì Synced library package.json to ${version}`);
  }
  
  return version;
}

/**
 * Main version bump function
 */
function bumpVersionCommand(type) {
  console.log(`\nüöÄ Bumping ${type} version...\n`);
  
  // Read current versions
  const rootPackage = readPackageJson(ROOT_PACKAGE_JSON);
  const libPackage = readPackageJson(LIB_PACKAGE_JSON);
  
  // Use library version as source of truth
  const currentVersion = libPackage.version || rootPackage.version;
  console.log(`Current version: ${currentVersion}`);
  
  // Bump version
  const newVersion = bumpVersion(currentVersion, type);
  console.log(`New version: ${newVersion}\n`);
  
  // Update both package.json files
  updatePackageVersion(ROOT_PACKAGE_JSON, newVersion);
  updatePackageVersion(LIB_PACKAGE_JSON, newVersion);
  
  // Generate version.ts
  const buildDate = new Date().toISOString();
  generateVersionFile(newVersion, buildDate);
  
  // Update CHANGELOG.md
  updateChangelog(newVersion, type);
  
  console.log(`\n‚úÖ Version bumped to ${newVersion}`);
  console.log(`\nNext steps:`);
  console.log(`  1. Review and update CHANGELOG.md`);
  console.log(`  2. Commit changes: git add -A && git commit -m "chore: bump version to ${newVersion}"`);
  console.log(`  3. Create tag: git tag -a v${newVersion} -m "Release ${newVersion}"`);
  console.log(`  4. Push: git push && git push --tags\n`);
}

/**
 * Show current version
 */
function showVersion() {
  const rootPackage = readPackageJson(ROOT_PACKAGE_JSON);
  const libPackage = readPackageJson(LIB_PACKAGE_JSON);
  
  console.log('\nüì¶ Current Versions:');
  console.log(`   Root package:    ${rootPackage.version}`);
  console.log(`   Library package: ${libPackage.version}`);
  
  if (rootPackage.version !== libPackage.version) {
    console.log('\n‚ö†Ô∏è  Warning: Versions are out of sync!');
    console.log('   Run: npm run version:sync\n');
  } else {
    console.log('   ‚úì Versions are synchronized\n');
  }
}

// CLI handling
const command = process.argv[2];

switch (command) {
  case 'patch':
  case 'minor':
  case 'major':
  case 'prerelease':
    bumpVersionCommand(command);
    break;
  case 'sync':
    const version = syncVersions();
    const buildDate = new Date().toISOString();
    generateVersionFile(version, buildDate);
    console.log(`\n‚úÖ Versions synchronized to ${version}\n`);
    break;
  case 'show':
    showVersion();
    break;
  default:
    console.log(`
Version Manager

Usage:
  node scripts/version-manager.js <command>

Commands:
  patch       Bump patch version (1.0.0 -> 1.0.1)
  minor       Bump minor version (1.0.0 -> 1.1.0)
  major       Bump major version (1.0.0 -> 2.0.0)
  prerelease  Create prerelease version (1.0.0 -> 1.0.1-rc.0)
  sync        Sync versions between main and library
  show        Show current version

Examples:
  npm run version:patch
  npm run version:minor
  npm run version:major
  npm run version:sync
  npm run version:show
`);
    process.exit(1);
}

