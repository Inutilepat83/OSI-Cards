#!/usr/bin/env node
/**
 * Bundle Size Report Generator
 *
 * Analyzes bundle stats and generates a detailed report.
 */

const fs = require('fs');
const path = require('path');

const STATS_FILE = 'dist/osi-cards/stats.json';
const REPORT_FILE = 'bundle-report.md';

// Size limits (in bytes)
const LIMITS = {
  main: 500 * 1024, // 500KB
  polyfills: 150 * 1024, // 150KB
  total: 1024 * 1024, // 1MB
};

function formatBytes(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

function generateReport() {
  if (!fs.existsSync(STATS_FILE)) {
    console.error('‚ùå Stats file not found. Run: npm run build -- --stats-json');
    process.exit(1);
  }

  const stats = JSON.parse(fs.readFileSync(STATS_FILE, 'utf8'));

  // Extract bundle information
  const assets = stats.assets || [];
  const chunks = stats.chunks || [];

  // Calculate sizes
  let mainSize = 0;
  let polyfillsSize = 0;
  let totalSize = 0;

  assets.forEach(asset => {
    const size = asset.size || 0;
    totalSize += size;

    if (asset.name.includes('main')) {
      mainSize += size;
    } else if (asset.name.includes('polyfills')) {
      polyfillsSize += size;
    }
  });

  // Generate report
  let report = '# üì¶ Bundle Size Report\n\n';
  report += `**Generated:** ${new Date().toISOString()}\n\n`;
  report += '---\n\n';
  report += '## üìä Bundle Sizes\n\n';
  report += '| Bundle | Size | Limit | Status |\n';
  report += '|--------|------|-------|--------|\n';
  report += `| Main | ${formatBytes(mainSize)} | ${formatBytes(LIMITS.main)} | ${mainSize <= LIMITS.main ? '‚úÖ' : '‚ùå'} |\n`;
  report += `| Polyfills | ${formatBytes(polyfillsSize)} | ${formatBytes(LIMITS.polyfills)} | ${polyfillsSize <= LIMITS.polyfills ? '‚úÖ' : '‚ùå'} |\n`;
  report += `| **Total** | **${formatBytes(totalSize)}** | **${formatBytes(LIMITS.total)}** | **${totalSize <= LIMITS.total ? '‚úÖ' : '‚ùå'}** |\n\n`;

  // Top 10 largest assets
  const sortedAssets = assets
    .filter(a => a.name.endsWith('.js'))
    .sort((a, b) => b.size - a.size)
    .slice(0, 10);

  report += '## üì¶ Largest Assets\n\n';
  report += '| File | Size |\n';
  report += '|------|------|\n';
  sortedAssets.forEach(asset => {
    report += `| ${asset.name} | ${formatBytes(asset.size)} |\n`;
  });
  report += '\n';

  // Recommendations
  report += '## üí° Recommendations\n\n';

  if (mainSize > LIMITS.main) {
    report += '- ‚ö†Ô∏è **Main bundle too large:** Consider code splitting\n';
  }

  if (polyfillsSize > LIMITS.polyfills) {
    report += '- ‚ö†Ô∏è **Polyfills too large:** Review browser support targets\n';
  }

  if (totalSize > LIMITS.total) {
    report += '- ‚ö†Ô∏è **Total bundle too large:** Implement lazy loading\n';
  }

  if (totalSize <= LIMITS.total && mainSize <= LIMITS.main) {
    report += '- ‚úÖ All bundles within limits!\n';
  }

  report += '\n---\n\n';
  report += '**Generated by:** bundle-report.js\n';

  // Write report
  fs.writeFileSync(REPORT_FILE, report);

  console.log('‚úÖ Bundle report generated:', REPORT_FILE);
  console.log('');
  console.log('üìä Summary:');
  console.log(`   Main: ${formatBytes(mainSize)} ${mainSize <= LIMITS.main ? '‚úÖ' : '‚ùå'}`);
  console.log(`   Polyfills: ${formatBytes(polyfillsSize)} ${polyfillsSize <= LIMITS.polyfills ? '‚úÖ' : '‚ùå'}`);
  console.log(`   Total: ${formatBytes(totalSize)} ${totalSize <= LIMITS.total ? '‚úÖ' : '‚ùå'}`);

  // Exit with error if limits exceeded
  if (totalSize > LIMITS.total || mainSize > LIMITS.main) {
    process.exit(1);
  }
}

generateReport();

