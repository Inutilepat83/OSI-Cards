#!/usr/bin/env node

/**
 * Vulnerability Scanning Script
 * 
 * Scans dependencies for known vulnerabilities using npm audit.
 * Can be extended to support Snyk, OWASP Dependency-Check, etc.
 * 
 * Usage:
 *   node scripts/vulnerability-scan.js [--json] [--fail-on-critical]
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const FAIL_ON_CRITICAL = process.argv.includes('--fail-on-critical');
const JSON_OUTPUT = process.argv.includes('--json');
const OUTPUT_FILE = process.argv.includes('--output') 
  ? process.argv[process.argv.indexOf('--output') + 1]
  : 'vulnerability-report.json';

/**
 * Severity levels
 */
const SEVERITY_LEVELS = {
  critical: 4,
  high: 3,
  moderate: 2,
  low: 1,
  info: 0
};

/**
 * Run npm audit and parse results
 */
function runNpmAudit() {
  try {
    console.log('ðŸ” Running npm audit...');
    const auditOutput = execSync('npm audit --json', { 
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
    
    return JSON.parse(auditOutput);
  } catch (error) {
    // npm audit exits with non-zero code if vulnerabilities are found
    if (error.stdout) {
      try {
        return JSON.parse(error.stdout);
      } catch (parseError) {
        console.error('âŒ Failed to parse npm audit output:', parseError.message);
        process.exit(1);
      }
    }
    console.error('âŒ Failed to run npm audit:', error.message);
    process.exit(1);
  }
}

/**
 * Analyze vulnerabilities
 */
function analyzeVulnerabilities(auditData) {
  const vulnerabilities = auditData.vulnerabilities || {};
  const advisories = auditData.advisories || {};
  
  const summary = {
    total: auditData.metadata?.vulnerabilities?.total || 0,
    critical: auditData.metadata?.vulnerabilities?.critical || 0,
    high: auditData.metadata?.vulnerabilities?.high || 0,
    moderate: auditData.metadata?.vulnerabilities?.moderate || 0,
    low: auditData.metadata?.vulnerabilities?.low || 0,
    info: auditData.metadata?.vulnerabilities?.info || 0,
    dependencies: Object.keys(vulnerabilities).length,
    advisories: Object.keys(advisories).length
  };
  
  const detailedVulns = Object.entries(vulnerabilities).map(([name, vuln]) => {
    const advisory = advisories[vuln.via?.[0]] || {};
    return {
      package: name,
      severity: vuln.severity || 'unknown',
      title: advisory.title || 'Unknown vulnerability',
      url: advisory.url || '',
      patchedVersions: advisory.patched_versions || 'No patch available',
      dependencyOf: vuln.dependencyOf || [],
      via: vuln.via || []
    };
  }).sort((a, b) => {
    return (SEVERITY_LEVELS[b.severity] || 0) - (SEVERITY_LEVELS[a.severity] || 0);
  });
  
  return {
    summary,
    vulnerabilities: detailedVulns,
    metadata: {
      auditVersion: auditData.metadata?.auditVersion || 'unknown',
      runDate: new Date().toISOString(),
      npmVersion: auditData.metadata?.npmVersion || 'unknown'
    }
  };
}

/**
 * Generate report
 */
function generateReport(analysis) {
  const report = {
    timestamp: new Date().toISOString(),
    summary: analysis.summary,
    vulnerabilities: analysis.vulnerabilities,
    metadata: analysis.metadata,
    recommendations: generateRecommendations(analysis)
  };
  
  if (JSON_OUTPUT) {
    const outputPath = path.resolve(OUTPUT_FILE);
    fs.writeFileSync(outputPath, JSON.stringify(report, null, 2));
    console.log(`\nðŸ“„ Report saved to: ${outputPath}`);
  }
  
  return report;
}

/**
 * Generate recommendations
 */
function generateRecommendations(analysis) {
  const recommendations = [];
  
  if (analysis.summary.critical > 0) {
    recommendations.push({
      priority: 'critical',
      action: 'Immediately update packages with critical vulnerabilities',
      packages: analysis.vulnerabilities
        .filter(v => v.severity === 'critical')
        .map(v => v.package)
    });
  }
  
  if (analysis.summary.high > 0) {
    recommendations.push({
      priority: 'high',
      action: 'Update packages with high severity vulnerabilities',
      packages: analysis.vulnerabilities
        .filter(v => v.severity === 'high')
        .map(v => v.package)
    });
  }
  
  if (analysis.summary.moderate > 0) {
    recommendations.push({
      priority: 'moderate',
      action: 'Review and update packages with moderate vulnerabilities',
      packages: analysis.vulnerabilities
        .filter(v => v.severity === 'moderate')
        .slice(0, 10) // Limit to top 10
        .map(v => v.package)
    });
  }
  
  if (analysis.summary.total === 0) {
    recommendations.push({
      priority: 'info',
      action: 'No vulnerabilities found. Keep dependencies up to date.',
      packages: []
    });
  }
  
  return recommendations;
}

/**
 * Print summary
 */
function printSummary(report) {
  console.log('\nðŸ“Š Vulnerability Scan Summary');
  console.log('â•'.repeat(50));
  console.log(`Total Vulnerabilities: ${report.summary.total}`);
  console.log(`  Critical: ${report.summary.critical}`);
  console.log(`  High: ${report.summary.high}`);
  console.log(`  Moderate: ${report.summary.moderate}`);
  console.log(`  Low: ${report.summary.low}`);
  console.log(`  Info: ${report.summary.info}`);
  console.log(`Affected Dependencies: ${report.summary.dependencies}`);
  console.log(`Advisories: ${report.summary.advisories}`);
  
  if (report.summary.critical > 0 || report.summary.high > 0) {
    console.log('\nâš ï¸  High Priority Vulnerabilities:');
    report.vulnerabilities
      .filter(v => v.severity === 'critical' || v.severity === 'high')
      .slice(0, 10)
      .forEach(v => {
        console.log(`  â€¢ ${v.package} (${v.severity}): ${v.title}`);
        if (v.url) {
          console.log(`    ${v.url}`);
        }
      });
  }
  
  if (report.recommendations.length > 0) {
    console.log('\nðŸ’¡ Recommendations:');
    report.recommendations.forEach(rec => {
      if (rec.packages.length > 0) {
        console.log(`  ${rec.priority.toUpperCase()}: ${rec.action}`);
        console.log(`    Packages: ${rec.packages.slice(0, 5).join(', ')}${rec.packages.length > 5 ? '...' : ''}`);
      } else {
        console.log(`  ${rec.action}`);
      }
    });
  }
  
  console.log('\n');
}

/**
 * Main execution
 */
function main() {
  console.log('ðŸ” Starting vulnerability scan...\n');
  
  const auditData = runNpmAudit();
  const analysis = analyzeVulnerabilities(auditData);
  const report = generateReport(analysis);
  
  if (!JSON_OUTPUT) {
    printSummary(report);
  }
  
  // Exit with error code if critical vulnerabilities found and --fail-on-critical is set
  if (FAIL_ON_CRITICAL && analysis.summary.critical > 0) {
    console.error('âŒ Critical vulnerabilities found. Failing build.');
    process.exit(1);
  }
  
  // Exit with warning code if high vulnerabilities found
  if (analysis.summary.high > 0) {
    console.warn('âš ï¸  High severity vulnerabilities found.');
    process.exit(analysis.summary.critical > 0 ? 1 : 0);
  }
  
  if (analysis.summary.total === 0) {
    console.log('âœ… No vulnerabilities found!');
  }
  
  process.exit(0);
}

// Run if executed directly
if (require.main === module) {
  main();
}

module.exports = { runNpmAudit, analyzeVulnerabilities, generateReport };



























